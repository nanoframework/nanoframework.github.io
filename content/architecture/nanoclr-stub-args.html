<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Native tips &amp; tricks, generating stubs for a native project, NANOCLR macros, Arguments and return types | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Native tips &amp; tricks, generating stubs for a native project, NANOCLR macros, Arguments and return types | .NET nanoFramework Documentation ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../x-cross/toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/nanoclr-stub-args.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="native-tips--tricks-generating-stubs-for-a-native-project-nanoclr-macros-arguments-and-return-types">Native tips &amp; tricks, generating stubs for a native project, NANOCLR macros, Arguments and return types</h1>

<p>When you want to use native code and creating an associated managed code C# library, you should start by reading <a href="https://jsimoesblog.wordpress.com/2018/06/19/interop-in-net-nanoframework/">this article</a>. This article will give you all the steps to create your managed C# project, generate the stubs and have everything glued together.</p>
<p>Once this is done, you'll still have to understand couple of elements related to the <code>NANOCLR</code> macros and the arguments and type conversions.</p>
<h2 id="nanoclr-macros">NANOCLR macros</h2>
<p>Once you generate the stubs, you'll have functions that looks like:</p>
<pre><code class="lang-cpp">HRESULT Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::NativeInit___VOID( CLR_RT_StackFrame &amp;stack )
{
    NANOCLR_HEADER();

    NANOCLR_SET_AND_LEAVE(stack.NotImplementedStub());

    NANOCLR_NOCLEANUP();
}
</code></pre>
<p>Every native code that is surfaced with the managed C# code will be generated with pre setup <code>NANOCLR</code> macros. They call all be found in <a href="https://github.com/nanoframework/nf-interpreter/blob/f5d026224116bd671f42d5c482701447b1bf6e70/src/CLR/Include/nanoCLR_Interop.h"><code>src\CLR\Include\nanoCLR_Interop.h</code></a>. With all the elements below, you will be able to understand how to best use them.</p>
<h3 id="nanoclr_header">NANOCLR_HEADER</h3>
<p>The <code>NANOCLR_HEADER</code> is always present at the top of each generated function. It's purpose is ti create the <code>HRESULT hr</code> variable.</p>
<h3 id="nanoclr_cleanup-or-nanoclr_nocleanup-label-or-nolabel">NANOCLR_CLEANUP or NANOCLR_NOCLEANUP, LABEL or NOLABEL</h3>
<p>the <code>CLEANUP</code> family includes 4 declinations and few more elements:</p>
<pre><code class="lang-cpp">#define NANOCLR_LEAVE()  goto nanoCLR_Cleanup // Note: this is a bit simplified version when Debug is not used
#define NANOCLR_RETURN() return hr

#define NANOCLR_CLEANUP()     hr = S_OK; nanoCLR_Cleanup:
#define NANOCLR_CLEANUP_END() NANOCLR_RETURN()
#define NANOCLR_NOCLEANUP()   NANOCLR_CLEANUP(); NANOCLR_CLEANUP_END()
#define NANOCLR_NOCLEANUP_NOLABEL() hr = S_OK; NANOCLR_RETURN()
</code></pre>
<p>So to demystify and understand which one to use, the <code>NANOCLR_NOCLEANUP_NOLABEL();</code> is equivalent to: <code>hr = S_OK; return hr;</code>. So if you don't have to clean anything, that your code is straight forward, that's the general case you can use.</p>
<p>Looking at the <code>NANOCLR_NOCLEANUP</code> one, you'll have something added in the equivalent, a label: <code>hr = S_OK; nanoCLR_Cleanup:; return hr;</code>. As you see the label has been added and looking at few more definition, the <code>NANOCLR_LEAVE</code> macro is <code>goto nanoCLR_Cleanup</code> meaning, anything that needs some check and may leave earlier than a straight forward way will need to have the label version used.</p>
<p>The variation with <code>CLEANUP_END</code> is here to just return hr, it's as well one that can be used when you have nothing to check. While the  <code>NANOCLR_CLEANUP</code> one sets the hr to ok and place the label. It can't be used alone, the <code>NANOCLR_LEAVE</code> will have to be used after.</p>
<h3 id="nanoclr_set_and_leave-nanoclr_check_hresult-and-nanoclr_exit_on_success">NANOCLR_SET_AND_LEAVE, NANOCLR_CHECK_HRESULT and NANOCLR_EXIT_ON_SUCCESS</h3>
<p>Those <code>NANOCLR_CHECK_HRESULT</code> and <code>NANOCLR_EXIT_ON_SUCCESS</code> macros allow you to check if a call to a function or an expression has failed or succeeded and then, as we've seen previously, go to <code>nanoCLR_Cleanup</code>. This is used a lot when you are calling other similar function returning as well an <code>HRESULT</code>.</p>
<pre><code class="lang-cpp">#define NANOCLR_CHECK_HRESULT(expr)   { if(FAILED(hr = (expr))) NANOCLR_LEAVE(); }
#define NANOCLR_EXIT_ON_SUCCESS(expr) { if(SUCCEEDED(hr = (expr))) NANOCLR_LEAVE(); }
#define NANOCLR_SET_AND_LEAVE(expr)   { hr = (expr); NANOCLR_LEAVE(); }
</code></pre>
<p>The <code>NANOCLR_SET_AND_LEAVE</code> function will just set the <code>HRESULT</code> and go to <code>nanoCLR_Cleanup</code>.</p>
<p>You will find a detailed list of typical HRESULT in the <a href="https://github.com/nanoframework/nf-interpreter/blob/f5d026224116bd671f42d5c482701447b1bf6e70/src/CLR/Include/nf_errors_exceptions.h"><code>src\CLR\Include\nf_errors_exceptions.h</code></a> file. FAILED and SUCCEEDED are defined like this:</p>
<pre><code class="lang-cpp">#define SUCCEEDED(Status) ((HRESULT)(Status) &gt;= 0)
#define FAILED(Status)    ((HRESULT)(Status)&lt;0)
</code></pre>
<h3 id="nanoclr_msg_set_and_leave-and-nanoclr_msg1_set_and_leave">NANOCLR_MSG_SET_AND_LEAVE and NANOCLR_MSG1_SET_AND_LEAVE</h3>
<p>Those 2 macros are defined like this:</p>
<pre><code class="lang-cpp">#define NANOCLR_MSG_SET_AND_LEAVE(expr, msg)       { hr = (expr); NANOCLR_LEAVE(); }
#define NANOCLR_MSG1_SET_AND_LEAVE(expr, msg, arg) { hr = (expr); NANOCLR_LEAVE(); }
</code></pre>
<p>So they allow you to setup the return element and leave. Those are so far used only in the <code>src\CLR\Core\TypeSystem.cpp</code> file. That said, nothing prevent you to use them as well.</p>
<h2 id="clr_rt_stackframe-stack">CLR_RT_StackFrame &amp;stack</h2>
<p>At every call to one of those native functions, the stack is passed thru a structure called CLR_RT_StackFrame. The definition can be found in <code>src\CLR\Include\nanoCLR_Runtime.h</code>. It would be too long to go thru all the functions and properties. In this description we will focus only on few elements.</p>
<h3 id="if-your-function-is-in-a-static-class">If your function is in a static class</h3>
<p>In, this case, the stack class that you'll get it's is the &quot;static instance&quot; of the C# class. The pointer to the class instance is only available for non static calls. The reason for this is that the execution engine adds a pointer to the class instance to the IL stack, when there is an instance of it.</p>
<h3 id="getting-and-checking-the-stack-in-a-non-static-class">Getting and checking the stack in a non static class</h3>
<p>The pattern to use is the following:</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock* pThis = stack.This();
FAULT_ON_NULL(pThis);
</code></pre>
<p><code>FAULT_ON_NULL</code> is a macro similar to the onces presented in the previous section which will check of the stack is null or not. In case of null it will go to the <code>nanoCLR_Cleanup</code> label and set the <code>HRESULT</code> to a null fault.</p>
<p>The definition can be found in <code>src\CLR\Include\nanoCLR_Interop.h</code>.</p>
<pre><code class="lang-cpp">#define FAULT_ON_NULL(ptr)     if(!(ptr)) NANOCLR_SET_AND_LEAVE(CLR_E_NULL_REFERENCE)
#define FAULT_ON_NULL_ARG(ptr) if(!(ptr)) NANOCLR_SET_AND_LEAVE(CLR_E_ARGUMENT_NULL)
</code></pre>
<p>You can use those macro for arguments too. We will see this in one of the following section.</p>
<h3 id="getting-any-exposed-field-from-the-stack">Getting any exposed field from the stack</h3>
<p>Once you've checked that the stack is valid, you can get a pointer to any of the class fields. Here is a typical example:</p>
<pre><code class="lang-cpp">int pinNumber = (int)(pThis[Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::FIELD___pinNumber].NumericByRef().u4);
</code></pre>
<p>The stack is a <code>CLR_RT_HeapBlock</code>. This type is the core type that allows you get access to a Heap Block, which are the objects that are placed in the IL stack.</p>
<p>The pattern to use is the array one: <code>pthis[the_field_to_get]</code> where you have to make sure the field does exist. To avoid any issue, it is recommended to use the long names like <code>Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::FIELD___pinNumber</code>. But if it's in the same class, you don't need the long naming, <code>pThis[FIELD___pinNumber]</code> will just work as well.</p>
<p>Then the <code>NumericByRef()</code> allows you to get a numerical number and <code>u4</code> to convert it as a <code>uint32</code>. For numerics, you have as well <code>NumericByRefConst()</code> allowing to convert as a constant. Then you have <code>u</code> for non signed, 1, 2, 4 and 8 for the number of bytes. <code>i</code> for signed, <code>r4</code> for <code>float</code> and <code>r8</code> for <code>double</code>.</p>
<blockquote>
<p>Pro tip: the generated function definition contains the types and the return type. Example: <code>NativeSetActiveDutyCyclePercentage___VOID__U4</code> is void as return and U4 so uint32 for the first argument. This is done on purpose to help managing the return type and arguments.</p>
</blockquote>
<h2 id="arg0-arg1-argsn">Arg0, Arg1, ArgsN</h2>
<p>Helpers functions available to access the arguments. We will look at this in this section.</p>
<h3 id="static-class">Static class</h3>
<p>In a static class, the <code>stack.Arg0()</code> points the first Heap Block passed on the IL stack. As explained before, do <strong>not</strong> use <code>CLR_RT_HeapBlock* pThis = stack.This();</code> because that won't be a pointer to a class instance (again: this is a call to a static method, therefore there is no instance of the class).</p>
<h3 id="non-static-class">Non static class</h3>
<p>In a non static class, <code>stack.Arg0()</code> is equivalent to <code>stack.This()</code>. The first parameter passed from the C# method can be accessed with Arg1() and the following ones with equivalent calls that have the same index as the parameter.</p>
<h4 id="dereferencing-an-array">Dereferencing an array</h4>
<p>As an example, this time, let's use a function with an array:</p>
<pre><code class="lang-cpp">HRESULT Library_sys_dev_spi_native_System_Device_Spi_SpiDevice::NativeTransfer___VOID__SZARRAY_U2__SZARRAY_U2__BOOLEAN(CLR_RT_StackFrame &amp;stack)
</code></pre>
<p>In this function, the return type is void, it's a non static one, the first and third arguments are <code>SZARRAY</code>, the second and fourth <code>U2</code>.  Still in this example, you will access the first array like this:</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock_Array *writeBuffer;
uint8_t *writeData = NULL;
writeBuffer = stack.Arg1().DereferenceArray();
if (writeBuffer != NULL)
{
     writeData = (unsigned char *)writeBuffer-&gt;GetFirstElementUInt16();
    // Do something as it's not null
}
</code></pre>
<p>The <code>DereferenceArray()</code> array function will allow you to get an array and to get access to the first element (in this case it's a UInt16 array), you can use <code>GetFirstElementUInt16()</code>. Array have their own heap types: <code>CLR_RT_HeapBlock_Array</code>. As you can guess you have other Element functions for the various system types.</p>
<h4 id="dereferencing-an-object">Dereferencing an object</h4>
<p>Similar to the array, you can dereference an object, a class or a structure. You will then be able to access its fields. Let's use the <code>SpanByte</code> structure as an example.</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock *writeSpanByte;
CLR_RT_HeapBlock_Array *writeBuffer;
uint8_t *writeData = NULL;
int16_t writeSize = 0;
int16_t writeOffset = 0;
writeSpanByte = stack.Arg1().Dereference();
if (writeSpanByte != NULL)
{
    // get buffer
    writeBuffer = writeSpanByte[SpanByte::FIELD___array].DereferenceArray();
    if (writeBuffer != NULL)
    {
        // Get the write offset, only the elements defined by the span must be written, not the whole
        // array
        writeOffset = writeSpanByte[SpanByte::FIELD___start].NumericByRef().s4;

        // use the span length as write size, only the elements defined by the span must be written
        writeSize = writeSpanByte[SpanByte::FIELD___length].NumericByRef().s4;
        writeData = (unsigned char *)writeBuffer-&gt;GetElement(writeOffset);
    }
}
</code></pre>
<p>SpanByte contains internal fields which are a byte array, a start int32 and length int32 elements. Giving the start and length of the buffer to use. So the pattern is actually to get a reference on the SpanByte, check if not null, get an array reference on the array, check if not nul and you can then have the size of the array. The <code>GetElement()</code> function will point you in the element you need.</p>
<h4 id="argn">ArgN</h4>
<p>You only have 8 defined Arg, when you need to access them further, you can use <code>ArgN(the_number_to_access)</code>.</p>
<blockquote>
<p>Note: it is recommended to move to a class or structure when you start getting too many arguments.</p>
</blockquote>
<h3 id="getting-a-string">Getting a string</h3>
<p>The pattern to get a string from the stack is to use the function <code>RecoverString()</code> if will give you a string.</p>
<pre><code class="lang-cpp">const char* szText = stack.Arg1().RecoverString();
// You can well check if it's a valid non null string like any other heap element:
FAULT_ON_NULL(szText);
</code></pre>
<h3 id="setting-a-result">Setting a result</h3>
<p>You can setup a return result using the family functions <code>SetResult_</code>. System types are directly available like U1 or R4 or any other mentioned before. for example <code>stack.SetResult_U1(42)</code> will place 42 as the return value for a function returning a byte type.</p>
<p><code>SetResult_Object</code> allows you to return any valid object, class or structure.</p>
<p>To return a string, <code>SetResult_String</code> is your best friend. Note that this function returns an <code>HRESULT</code> and should be checked.</p>
<h3 id="functions-with-reference-parameters-and-how-to-set-them">Functions with reference parameters and how to set them</h3>
<p>It is possible to have a function that has reference parameters and to set them on the native side.</p>
<p>Here is an example with a static function but it does work as well with non static functions (you just need to start at Arg1 for the first parameter):</p>
<pre><code class="lang-chsarp">[MethodImpl(MethodImplOptions.InternalCall)]
private extern static void NativeGetVoltage(ref TouchHighVoltage touchHighVoltage, ref TouchLowVoltage touchLowVoltage, ref TouchHighVoltageAttenuation touchHighVoltageAttenuation);
</code></pre>
<p>And here is a full simple example on how to set the parameters back:</p>
<pre><code class="lang-cpp">HRESULT Library_nanoFramework_hardware_esp32_native_nanoFramework_Hardware_Esp32_Touch_TouchPad::NativeGetVoltage___STATIC__VOID__BYREF_nanoFrameworkHardwareEsp32TouchTouchHighVoltage__BYREF_nanoFrameworkHardwareEsp32TouchTouchLowVoltage__BYREF_nanoFrameworkHardwareEsp32TouchTouchHighVoltageAttenuation( CLR_RT_StackFrame &amp;stack )
{
    NANOCLR_HEADER();

    touch_high_volt_t refh;
    touch_low_volt_t refl;
    touch_volt_atten_t atten;

    // Get the voltage    
    if (touch_pad_get_voltage(&amp;refh, &amp;refl, &amp;atten) == ESP_OK)
    {
        CLR_RT_HeapBlock bhRefh;
        CLR_RT_HeapBlock bhRefl;
        CLR_RT_HeapBlock bhAtten;
        bhRefh.SetInteger(refh);
        NANOCLR_CHECK_HRESULT(bhRefh.StoreToReference(stack.Arg0(), 0));
        bhRefl.SetInteger(refl);
        NANOCLR_CHECK_HRESULT(bhRefl.StoreToReference(stack.Arg1(), 0));
        bhAtten.SetInteger(atten);
        NANOCLR_CHECK_HRESULT(bhAtten.StoreToReference(stack.Arg2(), 0));
    }
    else
    {
        NANOCLR_SET_AND_LEAVE(CLR_E_INVALID_OPERATION);
    }

    NANOCLR_NOCLEANUP();
}
</code></pre>
<p>The key element here is the first create a heap block <code>CLR_RT_HeapBlock bhRefh;</code>, then set the value <code>bhRefh.SetInteger(refh);</code> and finaly store it into the argument <code>NANOCLR_CHECK_HRESULT(bhRefh.StoreToReference(stack.Arg0(), 0));</code>.</p>
<p>Note that this is working as well with objects, arrays or string.</p>
<h2 id="generating-exceptions-and-other-hal-elements">Generating exceptions and other HAL elements</h2>
<p>It's possible to generate various exceptions from the native side. And it's as well possible to access more of the HAL elements.</p>
<h3 id="generating-exceptions">Generating exceptions</h3>
<p>This is straight forward, you can use <code>NANOCLR_SET_AND_LEAVE(THE_EXCEPTION)</code>. The list of exception is available in <a href="https://github.com/nanoframework/nf-interpreter/blob/main/src/CLR/Include/nf_errors_exceptions.h">this include file</a>.</p>
<p>You can use it like this:</p>
<pre><code class="lang-cpp">NANOCLR_HEADER();

// some code

if (somethingWrong)
{
    NANOCLR_SET_AND_LEAVE(CLR_E_INVALID_OPERATION);
}

// If somethingWrong, then the code here won't be executed. You'll go directly to the end

// This is where you'll arrive
NANOCLR_NOCLEANUP();
</code></pre>
<h3 id="checking-results-of-a-function">Checking results of a function</h3>
<p>You can check if the result of a HRESULT function is a success or not by using <code>NANOCLR_CHECK_HRESULT</code> and few others like <code>NANOCLR_EXIT_ON_SUCCESS</code>. All those macros are available and documented in <a href="https://github.com/nanoframework/nf-interpreter/blob/main/src/CLR/Include/nanoCLR_Interop.h">this include file</a>. They al require to use the same pattern like:</p>
<pre><code class="lang-cpp">NANOCLR_HEADER();

// some code

NANOCLR_CHECK_HRESULT(AnotherNativeFunctionOfHRESULT);

// If somethingWrong, then the code here won't be executed. You'll go directly to the end

// This is where you'll arrive
NANOCLR_NOCLEANUP();
</code></pre>
<h2 id="access-to-callback-before-soft-reboot">Access to callback before soft reboot</h2>
<p>Do you need to clean resources before a soft reboot? Yes, then you're covered. The function <code>HAL_AddSoftRebootHandler(FeatureSoftRebootHandler);</code> if here for you!</p>
<p>The <code>FeatureSoftRebootHandler</code> is a simple <code>void FunctionName()</code> handler. Add this into your initialization function and you'll be sure to be called before a soft reboot.</p>
<h2 id="checking-object-types-on-native-side">Checking object types on native side</h2>
<p>There are quite a few occasions where you want to pass an interface object on the native side.
Something like:</p>
<pre><code class="lang-csharp">[MethodImpl(MethodImplOptions.InternalCall)]
private extern static void NativeStartFilter(IFilterSetting periodSetting);

// With a simple IFilterSetting interface and 2 classes implementing the interface
public interface IFilterSetting
{
}

public class Esp32FilterSetting : IFilterSetting
{
    // Some private fields you'll access on the native side
    private uint _period;
    // And some public ones
}

public class S2S3FilterSetting : IFilterSetting
{
    // Different field here
    private int _anotherField
    // And more public fields
}
</code></pre>
<p>On the native side, you'll get a generated function and structures, they'll look like this:</p>
<pre><code class="lang-cpp">// The function definition, very classic
HRESULT Lib_Name::NativeStartFilter___STATIC__VOID__nanoFrameworkHardwareEsp32TouchIFilterSetting(CLR_RT_StackFrame &amp;stack)

struct Lib_Name_Esp32FilterSetting
{
    static const int FIELD___period = 1;

    //--//
};

struct Lib_Name_S2S3FilterSetting
{
    static const int FIELD___anotherField = 1;
  
    //--//
};
</code></pre>
<p>The question is how on the native side, you can check if <code>Esp32FilterSetting</code> has been passed or <code>S2S3FilterSetting</code>?</p>
<p>The following code snippet shows you how you how to achieve this:</p>
<pre><code class="lang-cpp">CLR_RT_TypeDescriptor typeParamType;
CLR_RT_HeapBlock *bhPeriodeSetting;

// Static function, argument 0 is the first argument
bhPeriodeSetting = stack.Arg0().Dereference();

// get type descriptor for parameter
NANOCLR_CHECK_HRESULT(typeParamType.InitializeFromObject(*bhPeriodeSetting));

CLR_RT_TypeDef_Index esp32FilteringTypeDef;
CLR_RT_TypeDescriptor esp32FilteringType;
CLR_RT_TypeDef_Index s2s3FilteringTypeDef;    
CLR_RT_TypeDescriptor s2s3FilteringType;

// init types to compare with bhPeriodeSetting parameter
// You need the full namespace here
g_CLR_RT_TypeSystem.FindTypeDef(&quot;Esp32FilterSetting&quot;, &quot;nanoFramework.Hardware.Esp32.Touch&quot;, esp32FilteringTypeDef);
esp32FilteringType.InitializeFromType(esp32FilteringTypeDef);

// You need the full namespace here
g_CLR_RT_TypeSystem.FindTypeDef(&quot;S2S3FilterSetting&quot;, &quot;nanoFramework.Hardware.Esp32.Touch&quot;, s2s3FilteringTypeDef);
s2s3FilteringType.InitializeFromType(s2s3FilteringTypeDef);


// sanity check for parameter type
if (!CLR_RT_ExecutionEngine::IsInstanceOf(typeParamType, esp32FilteringType, false))
{
    // We have an Esp32FilterSetting
    // Implement your logic with this class
}
else if (!CLR_RT_ExecutionEngine::IsInstanceOf(typeParamType, s2s3FilteringType, false))
{
    // We have a S2S3FilterSetting
    // Implement your logic with this class
}
else
{
    // It's not what we expect!
    NANOCLR_SET_AND_LEAVE(CLR_E_INVALID_PARAMETER);
}
</code></pre>
<p>This does allow complex scenarios where you can differentiate the native execution. It does allow other scenarios where the hardware matters and you have a generic class but specific hardware settings. It's now open to your imagination!</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/nanoclr-stub-args.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
