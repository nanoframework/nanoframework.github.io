<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Wire Protocol | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Wire Protocol | .NET nanoFramework Documentation ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../x-cross/toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/wire-protocol.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="wire-protocol">Wire Protocol</h1>

<h2 id="about-this-document">About this document</h2>
<p>This document describes the Wire Protocol used by .NET <strong>nanoFramework</strong> for debug and the booter stage.
The protocol follows the implementation of the .NET Micro Framework Wire Protocol. The intention is to review it later in order to improve and simplify it.</p>
<h2 id="wire-protocol-message">Wire Protocol Message</h2>
<p>The message basic structure is comprised by:</p>
<ul>
<li>Signature which is basically a marker to detect the start of a new message packet. Has a fixed length.</li>
<li>Header with several fields to cary packet sequence, flags, commands, CRC, etc. Has a fixed length.
<ul>
<li>CRC32 of header (for verification calculation this CRC32 field has to be zeroed).</li>
<li>CRC32 of payload, when it exists (for verification calculation this CRC32 field has to be zeroed).</li>
<li>Command code.</li>
<li>Sequence number of the message.</li>
<li>Sequence reply. Carries the sequence number of the message that the message is a reply to.</li>
<li>Flags.</li>
<li>Size of the payload.</li>
</ul>
</li>
<li>Payload for carrying data. Optional and its size is variable.</li>
</ul>
<p>You can check the details on <a href="https://github.com/nanoframework/nf-interpreter/blob/main/src/CLR/Include/WireProtocol.h">WireProtocol.h</a>.</p>
<h2 id="data-channels">Data channels</h2>
<p>Currently .NET <strong>nanoFramework</strong> Wire Protocol supports only serial channels. The plan is to add support for USB (using CDC class device) and TCP.
To ease the port to new HAL/platforms the code is architecture so that only minimal changes are required to add support for new implementations.</p>
<h2 id="receiving-and-transmitting-data">Receiving and transmitting data</h2>
<p>The code is architecture to receive and transmit data over a serial stream.
Preferably (and to use the reference implementation provided without much changes) the interface/API of the serial stream should:</p>
<ul>
<li>Allow checking if there is data available for reading.</li>
<li>Allow reading sequentially (FIFO fashion) the input stream for a definite number of bytes. Having a timeout for the read operation is ideal to prevent bad/incomplete read operations.</li>
<li>Allow writing to the transmit stream a definite number of bytes. Ideally in a non-blocking fashion to prevent bad/incomplete write operations.</li>
</ul>
<h2 id="receiver-workflow">Receiver workflow</h2>
<p>Follows a high-level description on how the Wire Protocol component works.</p>
<ul>
<li>RTOS thread - <code>ReceiverThread(...)</code> in <code>WireProtocol_ReceiverThread</code>(@ src\CLR\WireProtocol\WireProtocol_ReceiverThread.c) - that loops continuously checking for available data in the receiving channel.</li>
<li>On available data the reception of the message is initialized (WP_Message_Initialize) and prepared (WP_Message_PrepareReception) so the reception can actually occur and be processed by calling WP_Message_Process.</li>
<li>During the reception states the input stream is read (<code>WP_ReceiveBytes(...)</code> in <code>WireProtocol_HAL_Interface</code>(@ src\CLR\WireProtocol\WireProtocol_HAL_Interface.c)) so the message header is received and it's integrity checked. Follows the reception and the integrity check of the payload, if there is any.</li>
<li>After a successful reception of the header (and payload, if any) the <em>Process</em> state machine in <code>WireProtocol_Message</code>(@ src\CLR\WireProtocol\WireProtocol_Message.c)) reaches the <code>ReceiveState_CompletePayload</code> state and calls the <code>ProcessPayload(...)</code> function.</li>
<li>Inside <code>ProcessPayload(...)</code> the lookup table for the commands that are implemented is searched and, if the command is found, the respective handler is called. According to the command its processing can require extra processing or gathering data. Invariably the handler execution end with a call to <code>ReplyToCommand(...)</code> where the reply is sent back to the host device.</li>
<li>When executing <code>ReplyToCommand(...)</code> the output stream is written (<code>WP_TransmitMessage(...)</code> in <code>WireProtocol_HAL_Interface</code>(@ src\CLR\WireProtocol\WireProtocol_HAL_Interface.c)) with the reply message.</li>
</ul>
<h2 id="wire-protocol-commands">Wire Protocol Commands</h2>
<p>Processing a command is carried in a handler function.
The collection of the commands that are implemented is listed in <code>c_Lookup_Request</code>. This lookup structure is basically an array with the command code along with a pointer to the respective handler. It resides in <em>WireProtocol_App_Interface.c</em>.
The actual command implementation resides in <em>WireProtocol_Commands.c</em>.</p>
<h2 id="how-to-add-support-for-a-new-command">How to add support for a new command</h2>
<p>There are two groups of commands: monitor commands and debug commands.</p>
<p>In order to add a new monitor command you have to:</p>
<ul>
<li>Add the function declaration and any required structure and/or type definition in <code>WireProtocol_MonitorCommands.h</code>(@ src\CLR\WireProtocol\WireProtocol_MonitorCommands.h)</li>
<li>Add a weak prototype in <code>WireProtocol_MonitorCommands.c</code>(@ src\CLR\WireProtocol\WireProtocol_MonitorCommands.c)</li>
<li>The actual code for the command handler function (and any required helper functions or extra processing) is added at target level. For the reference implementation for nanoBooter in ChibiOS check <code>WireProtocol_MonitorCommands.c</code>(@ targets\CMSIS-OS\ChibiOS\nanoBooter\WireProtocol_MonitorCommands.c)</li>
</ul>
<p>To add the command to the collection of the supported monitor commands un-comment or add the respective line in the <code>c_Lookup_Request</code> variable in <em>WireProtocol_App_Interface.c</em> for both <code>nanoBooter</code>(@ targets\CMSIS-OS\ChibiOS\nanoBooter\WireProtocol_MonitorCommands.c) and/or <code>nanoCLR]</code>(@ targets\CMSIS-OS\ChibiOS\nanoCLR\WireProtocol_MonitorCommands.c).
Because this declaration uses a macro to add the declaration of a command, make sure the existing naming pattern is <em><strong>strictly</strong></em> followed.</p>
<p>This architecture tries to bring flexibility by making it easy to have different monitor commands for nanoBooter and nanoCLR and also having them implemented in different ways, if necessary.</p>
<p>To ease code portability from .NET Micro Framework code base and maintain an understandable implementation the naming has been maintained or minimally adapted from the original C++ code.
Try to follow this as much as possible when implementing new commands or porting the original C++ code to C.</p>
<h2 id="how-to-add-support-for-new-channels">How to add support for new channels</h2>
<p>Current Wire Protocol implementation has support for transmission over serial port (UART/USART) and serial over USB (USB CDC device class).
Support for TCP channel is planned at a later stage.</p>
<p>When adding support for new channels the functions <code>WP_ReceiveBytes(...)</code> and <code>WP_TransmitMessage(...)</code> in <em>WireProtocol_HAL_Interface.c</em> are the ones that need to be reworked. This implementation is target and board specific so it resides in the board folder. Check the reference implementation for the ST_STM32F4_DISCOVERY board here (@ targets\CMSIS-OS\ChibiOS\ST_STM32F4_DISCOVERY\common\WireProtocol_HAL_Interface.c).</p>
<p>On both, the relevant part is that they read/write to a serial stream a specified number of bytes. Preferably non blocking calls with a timeout. Please read the comments inside of each of those functions for the details.
The last piece that needs to be adjusted is the code inside the <code>ReceiverThread(...)</code> which is the RTOS thread that is running the Wire Protocol component. That thread is basically a loop with a wait state were the checks for existing data to be read on the input stream. On data available the <code>WP_Message_Process(...)</code> function is called.</p>
<h2 id="hal-interface">HAL interface</h2>
<p>The Wire Protocol requires the following functions in order to interface with the HAL.
Weak implementations of each function are part of the core code.</p>
<ul>
<li><code>WP_TransmitMessage(...)</code> in <code>WireProtocol_HAL_Interface.c</code>(@ src\CLR\WireProtocol\WireProtocol_HAL_Interface.c)</li>
<li><code>WP_ReceiveBytes(...)</code> in <code>WireProtocol_HAL_Interface.c</code>(@ src\CLR\WireProtocol\WireProtocol_HAL_Interface.c)</li>
<li><code>WP_CheckAvailableIncomingData(...)</code> in <code>WireProtocol_HAL_Interface.c</code>(@ src\CLR\WireProtocol\WireProtocol_HAL_Interface.c)</li>
</ul>
<p>An implementation for an STM32F4_DISCOVERY board with ChibiOS (including its HAL) is provided as a reference. Please check it at <code>WireProtocol_HAL_Interface</code>(@ targets\CMSIS-OS\ChibiOS\ST_STM32F4_DISCOVERY\common\WireProtocol_HAL_Interface.c).</p>
<p>When porting .NET <strong>nanoFramework</strong> to another RTOS or HAL follow the reference implementation to ease the port work.</p>
<h2 id="application-interface">Application interface</h2>
<p>The Wire Protocol requires the following functions in order to interface with it's client app.
Weak implementations of each function are part of the core code.</p>
<ul>
<li><code>WP_App_ProcessHeader(...)</code> in <code>WireProtocol_App_Interface.c</code>()</li>
<li><code>WP_App_ProcessPayload(...)</code> in <code>WireProtocol_App_Interface.c</code>()</li>
</ul>
<p>Actual implementations of these are to be provided by nanoBooter and nanoCLR. Please check the reference implementation for ChibiOS at <code>WireProtocol_App_Interface.c</code>(@ targets\CMSIS-OS\ChibiOS\nanoBooter\WireProtocol_App_Interface.c).</p>
<h2 id="debugging-wire-protocol-communications">Debugging Wire Protocol communications</h2>
<p>To ease debugging of Wire Protocol sessions there are available a set of CMake options to adjust the output of the Wire Protocol state machine and TX/Rx operations. The available options are:</p>
<ul>
<li>NF_WP_TRACE_ERRORS: Enable error tracing.</li>
<li>NF_WP_TRACE_HEADERS: Enable packet headers tracing.</li>
<li>NF_WP_TRACE_STATE: Enable tracing of the current state of the Wire Protocol sate machine.</li>
<li>NF_WP_TRACE_NODATA: Enable tracing of empty or incomplete packets.</li>
<li>NF_WP_TRACE_ALL: Enable all the options above. In case this setting is chosen it takes precedence over all the other and replaces when on.</li>
</ul>
<h2 id="crc32-validations">CRC32 validations</h2>
<p>In order to ensure Wire Protocol communications integrity the message header and payload have each a CRC32 field which is filled in with the CRC32 hash of the respective section. This allows the receiver to validate the integrity of both the header and the payload.</p>
<p>A target can choose <em>not</em> to implement that. The Wire Protocol layer in the debugger is able to automatically handle both situations.</p>
<p>To have a target image built <strong>without</strong> implementing CRC32 validation the option <code>NF_WP_IMPLEMENTS_CRC32=OFF</code> has to be passed to CMake.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/wire-protocol.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
