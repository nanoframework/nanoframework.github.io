<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Packaging, versioning and deployment | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Packaging, versioning and deployment | .NET nanoFramework Documentation ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../x-cross/toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/deployment.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="packaging-versioning-and-deployment">Packaging, versioning and deployment</h1>

<h2 id="about-this-document">About this document</h2>
<p>This document describes how your application and the .NET <strong>nanoFramework</strong> components required for your application are packaged and deployed to a hardware device. It also describes the versioning system used to relate the packages.</p>
<h2 id="components">Components</h2>
<p>For the purpose of this description, the general <a href="index.html">architecture</a> of a .NET <strong>nanoFramework</strong> application is presented in a different way.</p>
<p><img src="../../images/architecture-deployment-components.png" alt="Software components and flash memory"></p>
<p>The .NET <strong>nanoFramework</strong> makes it possible to write your application and class libraries in .NET and hides the device dependent implementation details as much as possible. Your application typically consists of a .NET application and perhaps one or more class libraries. If you have special requirements that are not covered by the .NET <strong>nanoFramework</strong> and make use of native/device specific libraries, your application can include a library component that has an implementation that is partly .NET and partly native.</p>
<p>The .NET <strong>nanoFramework</strong> itself is split into multiple components that can be selected for use in an application. Many components have an implementation that is partly .NET and partly native. The native implementation uses third party libraries for some of the functionality. Some part of the native implementation is device specific as it has to use the appropriate SDK to interact with the microcontroller.</p>
<p>Ultimately your application has to be deployed to the device, by writing the software to the flash memory of the microcontroller. The content of the flash memory can be divided into four sections: a booter that is used to start up the device and that is independent of the application, a section that is reserved for the .NET <strong>nanoFramework</strong> runtime (CLR), a section where the application will be deployed and some space to store extra files. The latter is only available for devices where the flash memory is sufficiently large.</p>
<h2 id="packaging-and-distribution-of-the-nanoframework-components">Packaging and distribution of the nanoFramework components</h2>
<p>Each of the .NET <strong>nanoFramework</strong> components has a class library as .NET implementation. The library is compiled to a .dll file for use in development environments and a <a href="pe-file.html">.pe file</a> that can be run on the device. Each library is distributed as a <a href="class-libraries.html">NuGet package</a>.</p>
<p><img src="../../images/architecture-deployment-managed-components.png" alt="Managed components are distributed via NuGet"></p>
<p>You select the NuGet packages required for your application and class libraries. The packages will ultimately be deployed to the device as part of your application. Framework class libraries that are not necessary for your application are not deployed to the device and do not take up space in flash memory.</p>
<p>The native implementation of the .NET <strong>nanoFramework</strong> components are not packaged individually. Instead a selection of components is combined with the third party and device specific libraries into a single package. That package is deployed to the device as nanoFramework CLR. It is in other documentation also referred to as <em>target</em>, as it determines what functionality your application can use.</p>
<p><img src="../../images/architecture-deployment-clr-deployment.png" alt="Native components are packaged as runtime"></p>
<p>For each device there are one or more of such packages. The selection of the components depends on the capabilities of a device. E.g., the native component of the nanoFramework.Device.Can component is omitted if the device does not have hardware support for a Can bus. The nanoFramework.Device.Bluetooth is only included for devices that have a sufficient amount of flash memory.</p>
<p>If your application does not have a native component, you'll use one of the pre-packaged runtimes/targets. There are both <a href="../reference-targets">reference</a> and <a href="../community-targets">community</a> targets. The targets are made available from an <a href="https://cloudsmith.io/%7Enet-nanoframework/repos/nanoframework-images/packages/">online repository</a> and should be deployed to the device using the <a href="https://github.com/nanoframework/nanoFirmwareFlasher">nanoff</a> tool. The <em>nanoff</em> tool also makes sure that an appropriate booter is present.</p>
<p>Apart from the <em>.bin</em> file that is deployed to the device, the package containing the runtime may also contains additional (device dependent) information that is used in the deployment process. Such as the partition of the flash memory in sections for the runtime, managed code and additional files.</p>
<h2 id="native-application-component-or-custom-runtime">Native application component or custom runtime</h2>
<p>In the .NET <strong>nanoFramework</strong> architecture all native components have to be part of a runtime/target, and a device can only have one runtime installed. If your application has a native component, or if you don't want to use a pre-packaged runtime but want to make your own selection of components to include, you'll have to create an application-specific runtime. It should be deployed to the device using the <a href="https://github.com/nanoframework/nanoFirmwareFlasher">nanoff</a> tool.</p>
<p><img src="../../images/architecture-deployment-clr-deployment.png" alt="Native application components are packaged as runtime"></p>
<p>Once a native component of your application is part of the runtime, it is treated in the same way as the native .NET <strong>nanoFramework</strong> components. The framework does not make a distinction between framework and non-framework native components.</p>
<h2 id="packaging-and-distribution-of-the-net-application-and-libraries">Packaging and distribution of the .NET application and libraries</h2>
<p>The .NET components of your application and the .NET <strong>nanoFramework</strong> framework components included via NuGet packages can be deployed to the device in three phases of the development cycle.</p>
<p>The first stage is during the development of the class libraries. The .NET <strong>nanoFramework</strong> framework supports (unit) testing of class libraries (not applications). The <a href="../unit-test">test platform</a> deploys the <a href="pe-file.html">.pe files</a> of the class libraries and a unit test launcher to the device and executes the tests.</p>
<p><img src="../../images/architecture-deployment-application-test.png" alt="Deployment of class libraries for testing"></p>
<p>The second stage is during the development of the integrated application. The .NET <strong>nanoFramework</strong> framework supports debugging of an application. The debugger that is part of the Visual Studio extension deploys the <a href="pe-file.html">.pe files</a> of the application and all referenced class libraries to the device and runs the application.</p>
<p><img src="../../images/architecture-deployment-application-debug.png" alt="Deployment of class libraries for debugging"></p>
<p>The last stage is the deployment of the final application. As part of the build process the application and referenced class libraries are packaged in an application.bin package. That package should be deployed to the device with the <a href="https://github.com/nanoframework/nanoFirmwareFlasher">nanoff</a> tool. The tool also allows for the deployment of additional files, if the device supports that.</p>
<p><img src="../../images/architecture-deployment-application-final.png" alt="Deployment of the final application"></p>
<p>The <em>nanoff</em> tool supports the deployment of the runtime/target and application in one go or in separate operations. Separate operations are required for testing and debugging: the test platform and debugger only deploy an application, the runtime and additional files should already be present on the device.</p>
<p>None of the .NET <strong>nanoFramework</strong> tools try to &quot;reuse&quot; what might be already deployed on the device. All the PE/.bin files are always deployed. This has the advantage of not requiring the extra steps of reading back what's in the device, checking the exact versions and deciding if a certain PE file will fit on a flash block. The downside is that sometimes this causes unnecessary flash erase and write cycles. Considering that a typical modern SoC flash endurance limit is in the range of 100k to 1M cycles this is negligible and acceptable for a device used for development purposes.</p>
<h2 id="component-versioning-and-consistency-checks">Component versioning and consistency checks</h2>
<p>A deployed application consists of many elements: the managed application components, referenced .NET <strong>nanoFramework</strong> class libraries, and a runtime with native application and framework components. The elements cannot be independently selected. The managed application depends on specific versions of the managed framework components. For each component the managed implementation is based on a specific version of the native component. A runtime contains a specific version of each native component. As native components share libraries and SDKs, a runtime cannot be composed of components of arbitrary versions.</p>
<p>The various elements are selected and incorporated at different moments in the build and deployment process, so the is no automatic guarantee that the element versions match in the deployed application and runtime. The framework uses a versioning system to enable the verification of the consistency of the components in the application and runtime.</p>
<p><img src="../../images/architecture-deployment-versioning.png" alt="Version-based references between components"></p>
<p>Each native implementation of a component has a <a href="guide-version-checksums.html">version and checksum</a>. .NET <strong>nanoFramework</strong> tools can obtain a list of native components and their version and checksum from the runtime once it is deployed on a device.</p>
<p>Each managed implementation of a component has a version as is common for .NET assemblies. If the component also has a native implementation, the .NET assembly also has a reference (via the <em>AssemblyNativeVersion</em> attribute) to the version of the native component. .NET <strong>nanoFramework</strong> tools can read the attribute.</p>
<p>The consistency of references from one .NET assembly to another is done by the regular .NET tooling like Visual Studio, MS Build and the (NuGet) package manager. Version conflicts are detected in the build process and have to be resolved before an <em>application.bin</em> or <em>.pe</em>-file can be created for deployment to a device.</p>
<p>The consistency of references from managed assemblies to the native components is done by .NET <strong>nanoFramework</strong> tools and components:</p>
<ul>
<li><p>Before an application starts to run on a device, the presence and version consistency of the native components is checked by reading the <em>AssemblyNativeVersion</em> attribute values. The application will not be run if a native component is missing or the <em>AssemblyNativeVersion</em> value is different from the version of the native component present in the runtime.</p>
</li>
<li><p>The same consistency check is done by the Visual Studio extension before the <em>.pe</em>-files of an application are deployed for debugging.</p>
</li>
</ul>
<h2 id="interdependency-of-tools-and-runtimes">Interdependency of tools and runtimes</h2>
<p>The description so far may give the impression that the .NET <strong>nanoFramework</strong> tools that support the packaging and deployment are independent of the packages the tools work with. That is not the case, there are a few interdependencies.</p>
<p>All tools except <em>nanoff</em> (and <em>nanoff</em> for additional files) do not write directly to the flash memory of a device. Instead they use a limited part of the <a href="wire-protocol.html">wire protocol</a> to send the <em>.pe</em>-files to the device, and the (already deployed) runtime writes to flash memory. The tool and the deployed runtime have to have the same perception that part of the wire protocol; (breaking) changes in the protocol may lead to incompatibility of tools and runtimes. Fortunately the wire protocol is very stable and changes are few and far between.</p>
<p>The <em>nanoff</em> tool has some hard-coded logic to select the most suitable pre-packaged runtime/target for a particular device. The runtime package does not contain sufficient information to link the (device manufacturer's specific) description that a device provides to the <em>nanoff</em> tool to the suitability of the runtime. E.g., a runtime may target a particular model of microcontroller, but if the microcontroller is part of a development kit, <em>nanoff</em> may receive an identification of the kit when querying the device instead of an identification of the microcontroller. If new pre-packaged runtimes/targets become available, the <em>nanoff</em> tool may require an update. The selection mechanism can always be bypassed by explicitly specifying the runtime/target to deploy.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/deployment.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
