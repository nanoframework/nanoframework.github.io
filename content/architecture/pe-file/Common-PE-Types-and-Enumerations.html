<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Philosophy | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Philosophy | .NET nanoFramework Documentation ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/pe-file/Common-PE-Types-and-Enumerations.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="philosophy">Philosophy</h1>

<p>The PE File format is expressed in terms of a number of common types. In code these are generally realized as an enumeration, typedef or type alias of some sort o help ensure both clarity of code and correctness of use. This additional clarity and type safety is preferred over use of raw primitive types directly as they onvey no real meaning beyond their basic ranges making correct use of the code less obvious and more error prone.</p>
<h2 id="table-index">Table Index</h2>
<p>Many PE data structures store Index into a particular table index as a field. This table defines the type names used to store the index and which table it is Index into.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>underlying type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the string table (see: <a href="StringTable.html">StringTables</a>) for more details)</td>
</tr>
<tr>
<td>TypeDefTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the type definition table</td>
</tr>
<tr>
<td>TypeRefTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the type reference table</td>
</tr>
<tr>
<td>FieldDefTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the field definition table</td>
</tr>
<tr>
<td>MethodDefTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the method definition table</td>
</tr>
<tr>
<td>SigTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the signature table (see: <a href="SignatureTable.html">SignatureBlobs</a> for more details)</td>
</tr>
<tr>
<td>GenericParamTableIndex</td>
<td>unsigned 8 bit integer</td>
<td>Index into the generic params table (OK to use 1 byte index because we won't support more than 255 generic parameters)</td>
</tr>
<tr>
<td>MethodSpecTableIndex</td>
<td>unsigned 16 bit integer</td>
<td>Index into the method specification table</td>
</tr>
</tbody>
</table>
<h2 id="emptyindex-constant">EmptyIndex Constant</h2>
<p>Since Index values are used to access members of a table and since (in C, C++, and many other languages) tables are indexed with the first element as index == 0 the value 0 is not useable as a constant to indicate &quot;none&quot; or &quot;null&quot;. Thus a dedicated value is used for .NET <strong>nanoFramework</strong> metadata tables. Any index with the value 0xFFFF is considered the EmptyIndex and this is normally defined as a manifest constant for the entire code base to test against.</p>
<h2 id="table-kind">Table Kind</h2>
<p>The CLR_TABLESENUM enumeration identifies a specific table in the assembly metadata.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AssemblyRef</td>
<td>0x0000</td>
<td>Assembly reference table</td>
</tr>
<tr>
<td>TypeRef</td>
<td>0x0001</td>
<td>Type Reference Table</td>
</tr>
<tr>
<td>FieldRef</td>
<td>0x0002</td>
<td>Field Reference table</td>
</tr>
<tr>
<td>MethodRef</td>
<td>0x0003</td>
<td>Method Reference Table</td>
</tr>
<tr>
<td>TypeDef</td>
<td>0x0004</td>
<td>Type Definition Table</td>
</tr>
<tr>
<td>FieldDef</td>
<td>0x0005</td>
<td>Field Definition Table</td>
</tr>
<tr>
<td>MethodDef</td>
<td>0x0006</td>
<td>Method Definition Table</td>
</tr>
<tr>
<td>GenericParam</td>
<td>0x0007</td>
<td>Generic Parameters Table</td>
</tr>
<tr>
<td>MethodSpec</td>
<td>0x0008</td>
<td>Method Specification Table</td>
</tr>
<tr>
<td>Attributes</td>
<td>0x0009</td>
<td>Attribute Table</td>
</tr>
<tr>
<td>TypeSpec</td>
<td>0x000A</td>
<td>Type Specification Table</td>
</tr>
<tr>
<td>Resources</td>
<td>0x000B</td>
<td>Resources Table</td>
</tr>
<tr>
<td>ResourcesData</td>
<td>0x000C</td>
<td>Resource Data Blob Table</td>
</tr>
<tr>
<td>Strings</td>
<td>0x000D</td>
<td>String Blob table</td>
</tr>
<tr>
<td>Signatures</td>
<td>0x000E</td>
<td>Signature Blob table</td>
</tr>
<tr>
<td>ByteCode</td>
<td>0x000F</td>
<td>IL Byte Code Stream Blob Table</td>
</tr>
<tr>
<td>ResourcesFiles</td>
<td>0x0010</td>
<td>Resource Files Table</td>
</tr>
<tr>
<td>EndOfAssembly</td>
<td>0x0011</td>
<td>End of Assembly Table (Used to quickly find the end of the assembly when scanning assemblies)</td>
</tr>
<tr>
<td>Max</td>
<td>0x0012</td>
<td>End of enumeration valid enumeration values must be <strong><em>less</em></strong> than this value</td>
</tr>
</tbody>
</table>
<h2 id="miscellaneous-types">Miscellaneous Types</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>underlying type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MetadataOffset</td>
<td>unsigned 16 bit integer</td>
<td>Offset from the start of the IL instruction stream blob data</td>
</tr>
<tr>
<td>MetadataPtr</td>
<td>pointer to a const byte</td>
<td>Pointer to the interior of the IL instruction stream blob data</td>
</tr>
</tbody>
</table>
<h2 id="tokens">Tokens</h2>
<p>Many instructions in IL and fields of data structures contain a token. Tokens in IL Metadata reference some other piece of metadata in the assembly. Tokens contain the table the token refers to along with Index into the table into a single primitive integral value. In .NET <strong>nanoFramework</strong> PE files there are two kinds of tokens MetadataToken and a more compact BinaryToken.</p>
<h3 id="metadata-token">Metadata Token</h3>
<p>A metadata token is an unsigned 32 bit value where the Most significant byte is the table kind and the least significant 16 bits are the table index (In .NET <strong>nanoFramework</strong> PE format a table index is 16bits only thus there are 8 bits of unused data in a MetadataToken)</p>
<h3 id="binary-token">Binary Token</h3>
<p>A Binary Token is a compact form of representing Index to one or more tables. .NET <strong>nanoFramework</strong> follows the convention specified by ECMA-335 (I I.24.2.66) for <em>coded index</em> where the least significant bits are used to determine which of the possible tables and the remaining bits provide the index of the table entry.
Except for a few tags that, because of legacy code, use the most significant bits. Because of it's small size only the 2 bytes version is used. The following table provides the type name aliases for the various combinations of tables used in .NET <strong>nanoFramework</strong> PE metadata.</p>
<table>
<thead>
<tr>
<th>TypeRefOrAssemblyRef: (1 bit to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>AssemblyRef</td>
<td>0</td>
</tr>
<tr>
<td>TypeRef</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>TypeDefOrRef: (2 bits to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>TypeDef</td>
<td>0</td>
</tr>
<tr>
<td>TypeRef</td>
<td>1</td>
</tr>
<tr>
<td>TypeSpec</td>
<td>2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>MethodDefOrRef: (1 bit to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>MethodDef</td>
<td>0</td>
</tr>
<tr>
<td>MemberRef</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>MemberRefParent: (3 bits to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>TypeDef</td>
<td>0</td>
</tr>
<tr>
<td>TypeRef</td>
<td>1</td>
</tr>
<tr>
<td>ModuleRef</td>
<td>2</td>
</tr>
<tr>
<td>MethodDef</td>
<td>3</td>
</tr>
<tr>
<td>TypeSpec</td>
<td>4</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>TypeOrMethodDef: (1 bit to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>TypeDef</td>
<td>0</td>
</tr>
<tr>
<td>MethodDef</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>FieldRefOrFieldDef: (1 bit to encode tag)</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>FieldDef</td>
<td>0</td>
</tr>
<tr>
<td>FieldRef</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="versioninfo">VersionInfo</h2>
<p>Many .NET <strong>nanoFramework</strong> PE data structures include a version. The versions, when presented for readability are typically represented as a quad of 4 integer values separated by a '.' (i.e. 1.2.3.4) the following table defines the Version info structure used in the PE file to represent a version.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Major</td>
<td>unsigned 16 bit integer</td>
<td>Major component of the common version quad</td>
</tr>
<tr>
<td>Minor</td>
<td>unsigned 16 bit integer</td>
<td>Minor component of the common version quad</td>
</tr>
<tr>
<td>Build</td>
<td>unsigned 16 bit integer</td>
<td>Build component of the common version quad</td>
</tr>
<tr>
<td>Revision</td>
<td>unsigned 16 bit integer</td>
<td>Revision component of the common version quad</td>
</tr>
</tbody>
</table>
<h2 id="datatype">DataType</h2>
<p>The <code>DataType</code> enumeration corresponds to the ECMA-335 ELEMENT_TYPE_xxxx, however the
actual numeric values are not the same as the interpreter uses only a reduced
sub-set of the standard values.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Void</td>
<td>0 byte void value</td>
</tr>
<tr>
<td>Boolean</td>
<td>1 byte boolean value</td>
</tr>
<tr>
<td>I1</td>
<td>8 bit signed integer</td>
</tr>
<tr>
<td>U1</td>
<td>8 bit unsigned integer</td>
</tr>
<tr>
<td>CHAR</td>
<td>16 bit UTF-16 character</td>
</tr>
<tr>
<td>I2</td>
<td>16 bit signed integer</td>
</tr>
<tr>
<td>U2</td>
<td>16 bit unsigned integer</td>
</tr>
<tr>
<td>I4</td>
<td>32 bit signed integer</td>
</tr>
<tr>
<td>U4</td>
<td>32 bit unsigned integer</td>
</tr>
<tr>
<td>R4</td>
<td>32 bit IEEE-754 floating point value</td>
</tr>
<tr>
<td>I8</td>
<td>64 bit signed integer</td>
</tr>
<tr>
<td>U8</td>
<td>64 bit unsigned integer</td>
</tr>
<tr>
<td>R8</td>
<td>64 bit IEEE-754 floating point value</td>
</tr>
<tr>
<td>DateTime</td>
<td>8 bytes - Shortcut for System.DateTime</td>
</tr>
<tr>
<td>TimeSpan</td>
<td>8 bytes - Shortcut for System.TimeSpan</td>
</tr>
<tr>
<td>String</td>
<td>4 bytes - short cut for reference to System.String</td>
</tr>
<tr>
<td>Object</td>
<td>4 bytes - Shortcut for reference to System.Object</td>
</tr>
<tr>
<td>Class</td>
<td>CLASS <code>&lt;class Token&gt;</code></td>
</tr>
<tr>
<td>ValueType</td>
<td>VALUETYPE <code>&lt;class Token&gt;</code></td>
</tr>
<tr>
<td>SZArray</td>
<td>Shortcut for single dimension zero lower bound array SZARRAY <code>&lt;type&gt;</code></td>
</tr>
<tr>
<td>ByRef</td>
<td>BYREF <code>&lt;type&gt;</code></td>
</tr>
<tr>
<td>Var</td>
<td>VAR Generic parameter in a generic type definition, represented as number (new in v2.0)</td>
</tr>
<tr>
<td>GenericInst</td>
<td>GENERICINST Generic type instantiation (new in v2.0)</td>
</tr>
<tr>
<td>MVar</td>
<td>MVAR Generic parameter in a generic method definition, represented as number (new in v2.0)</td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/pe-file/Common-PE-Types-and-Enumerations.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
