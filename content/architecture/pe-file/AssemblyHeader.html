<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>AssemblyHeader (CLR_RECORD_ASSEMBLY) | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="AssemblyHeader (CLR_RECORD_ASSEMBLY) | .NET nanoFramework Documentation ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/pe-file/AssemblyHeader.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="assemblyheader-clr_record_assembly">AssemblyHeader (CLR_RECORD_ASSEMBLY)</h1>

<p>The AssemblyHeader structure contains a number of verification markers and CRCs to validate the legitimacy of the assembly at runtime. Additionally, the Assembly header contains the location information for the MetadataTables and BLOB storage areas.</p>
<p>The Structure of the AssemblyHeader is as follows:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#marker">Marker</a></td>
<td><code>uint8_t[8]</code></td>
<td>Id marker for an assembly</td>
</tr>
<tr>
<td><a href="#headercrc">HeaderCRC</a></td>
<td><code>uint32_t</code></td>
<td>CRC32 of the AssemblyHeader structure itself</td>
</tr>
<tr>
<td><a href="#assemblycrc">AssemblyCRC</a></td>
<td><code>uint32_t</code></td>
<td>CRC32 of the complete assembly</td>
</tr>
<tr>
<td><a href="#flags">Flags</a></td>
<td><a href="#flags">AssemblyHeaderFlags</a></td>
<td>Flags for the assembly</td>
</tr>
<tr>
<td><a href="#nativemethodschecksum">NativeMethodsChecksum</a></td>
<td><code>uint32_t</code></td>
<td>Native Method Checksum</td>
</tr>
<tr>
<td><a href="#nativemethodsoffset">NativeMethodsOffset</a></td>
<td><code>uint32_t</code></td>
<td>Native Methods Offset</td>
</tr>
<tr>
<td><a href="#version">Version</a></td>
<td><code>VersionInfo</code></td>
<td>Version information data structure for this assembly</td>
</tr>
<tr>
<td><a href="#assemblyname">AssemblyName</a></td>
<td><code>uint16_t</code></td>
<td>String table index for the Assembly's name</td>
</tr>
<tr>
<td><a href="#stringtableversion">StringTableVersion</a></td>
<td><code>uint16_t</code></td>
<td>String table version</td>
</tr>
<tr>
<td><a href="#startoftables">StartOfTables</a></td>
<td><code>uint32_t[16]</code></td>
<td>Array of offsets into the PE file for the metadata tables</td>
</tr>
<tr>
<td>NumberOfPatchedMethods</td>
<td><code>uint32_t</code></td>
<td>Number of patched methods</td>
</tr>
<tr>
<td><a href="#paddingoftables">PaddingOfTables</a></td>
<td><code>uint8_t[16]</code></td>
<td>amount of alignment padding for each metadata table</td>
</tr>
</tbody>
</table>
<h2 id="field-details">Field Details</h2>
<p>The following sections describe the individual fields of the AssemblyHeader structure.</p>
<h3 id="marker">Marker</h3>
<p>The assembly marker is an eight character marker consisting of a string non zero terminated ASCII encoded characters.
This is used to clearly identify a .NET <strong>nanoFramework</strong> PE file on disk and in memory at runtime. It also indicates the version of this data structure, thus any modifications to this structure in future releases <strong>MUST</strong> use a new marker string.</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Marker</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>'NFMRK1'</td>
<td>Marker for version 1.0</td>
</tr>
<tr>
<td>2.0</td>
<td>'NFMRK2'</td>
<td>Marker for version 2.0 (after adding support for generics)</td>
</tr>
</tbody>
</table>
<h3 id="headercrc">HeaderCRC</h3>
<p>ANSI X3.66 32 bit CRC for the AssemblyHeader. This is computed assuming the HeaderCRC is 0.</p>
<h3 id="assemblycrc">AssemblyCRC</h3>
<p>ANSI X3.66 32 bit CRC for the entire contents of the Assembly PE data starting from <a href="#paddingoftables">PaddingOfTables</a></p>
<h3 id="flags">Flags</h3>
<p>The flags property are meant to contain a bit flags value. They are not used in .NET <strong>nanoFramework</strong> and were kept for historical reasons and structure compatibility.</p>
<h3 id="nativemethodschecksum">NativeMethodsChecksum</h3>
<p>The <em><strong>NativeMethodsChecksum</strong></em> is a unique value that is matched against the native methods table stored in the CLR firmware to ensure the methods match. The actual algorithm used for computing this checksum are documented in the [NativeMethodsChecksum Algorithm] document. Though, it worth noting that the actual algorithm doesn't matter. Nothing in the runtime will compute this value. The runtime only compares the assembly's value with the one for the native code registered for a given assembly to ensure they match. As long as the tool generating the assembly and the native method stubs header and code files use the same value then the actual algorithm is mostly irrelevant. The most important aspect of the algorithm chosen is that any change to any type or method signature
of any type with native methods <strong>MUST</strong> generate a distinct checksum value. The current MetadataProcessor algorithm constructs a mangled string name for the native methods (used to generate the stubs), sorts them all and runs a CRC32 across them to get a distinct value. Since the CRC is based on the fully qualified method name and the types of all parameters any change of the signatures will generate a new value - denoting a mismatch.</p>
<h3 id="nativemethodsoffset">NativeMethodsOffset</h3>
<p>(TBD)</p>
<h3 id="version">Version</h3>
<p>The <em><strong>Version</strong></em> field holds the assembly's version number. (as opposed to the version of the AssemblyHeaderStructure itself). This is used by the debugger for version checks at deployment time. The runtime itself doesn't use versions to resolve references, as only one version of an assembly can be loaded at a time. Thus assembly references in the PE format don't include a version.</p>
<h3 id="assemblyname">AssemblyName</h3>
<p><a href="StringTable.html">String Table</a> index for the name of the assembly</p>
<h3 id="stringtableversion">StringTableVersion</h3>
<p>Should be equal to 1</p>
<h3 id="startoftables">StartOfTables</h3>
<p>Fixed array of offsets to the table data for each of the different tables. The entries in this array are offsets from the start of the assembly header itself (e.g. the file seek offset if the PE image is from a file)</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>.NET <strong>nanoFramework</strong> Source Element Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="AssemblyRefTableEntry.html">AssemblyRef</a></td>
<td>CLR_RECORD_ASSEMBLYREF</td>
<td>Table of Assembly references</td>
</tr>
<tr>
<td><a href="TypeRefTableEntry.html">TypeRef</a></td>
<td>CLR_RECORD_TYPEREF</td>
<td>Reference to a type in another assembly</td>
</tr>
<tr>
<td><a href="FieldRefTableEntry.html">FieldRef</a></td>
<td>CLR_RECORD_FIELDREF</td>
<td>Reference to a field of a type in another assembly</td>
</tr>
<tr>
<td><a href="MethodRefTableEntry.html">MethodRef</a></td>
<td>CLR_RECORD_METHODREF</td>
<td>Reference to a method of a type in another assembly</td>
</tr>
<tr>
<td><a href="TypeDefTableEntry.html">TypeDef</a></td>
<td>CLR_RECORD_TYPEDEF</td>
<td>Type definition for a type in this assembly</td>
</tr>
<tr>
<td><a href="FieldDefTableEntry.html">FieldDef</a></td>
<td>CLR_RECORD_FIELDDEF</td>
<td>Field definition for a type in this assembly</td>
</tr>
<tr>
<td><a href="MethodDefTableEntry.html">MethodDef</a></td>
<td>CLR_RECORD_METHODDEF</td>
<td>Method definition for a type in this assembly</td>
</tr>
<tr>
<td><a href="GenericParamTableEntry.html">GenericParam</a></td>
<td>CLR_RECORD_GENERICPARAM</td>
<td>Generic parameter definition (new in v2.0)</td>
</tr>
<tr>
<td><a href="MethodSpecTableEntry.html">MethodSpec</a></td>
<td>CLR_RECORD_METHODSPEC</td>
<td>Method specification (new in v2.0)</td>
</tr>
<tr>
<td><a href="AttributeTableEntry.html">Attributes</a></td>
<td>CLR_RECORD_ATTRIBUTE</td>
<td>Attribute types defined in this assembly</td>
</tr>
<tr>
<td><a href="TypeSpecTableEntry.html">TypeSpec</a></td>
<td>CLR_RECORD_TYPESPEC</td>
<td>TypeSpecifications (signatures) used in this assembly</td>
</tr>
<tr>
<td><a href="ResourcesTableEntry.html">Resources</a></td>
<td>CLR_RECORD_RESOURCE</td>
<td>Resource items in a resource file bound to this assembly</td>
</tr>
<tr>
<td><a href="ResourcesTableEntry.html">ResourcesData</a></td>
<td>&lt;blob&gt;</td>
<td>Blob table data for the resources</td>
</tr>
<tr>
<td><a href="StringTable.html">Strings</a></td>
<td>&lt;blob&gt;</td>
<td>Blob table data for the strings</td>
</tr>
<tr>
<td><a href="SignatureTable.html">Signatures</a></td>
<td>&lt;blob&gt;</td>
<td>Blob table data for the metadata signatures</td>
</tr>
<tr>
<td><a href="Common-PE-Types-and-Enumerations.html">ByteCode</a></td>
<td>&lt;blob&gt;</td>
<td>Blob table data for the IL byte code instructions</td>
</tr>
<tr>
<td><a href="ResourcesTableEntry.html">ResourcesFiles</a></td>
<td>CLR_RECORD_RESOURCE_FILE</td>
<td>Resource files descriptors for resource files bound to this assembly</td>
</tr>
<tr>
<td><a href="Common-PE-Types-and-Enumerations.html">EndOfAssembly</a></td>
<td>&lt;N/A&gt;</td>
<td>Technically, this is not a table. Instead this entry contains the offset to the end of the assembly, which is useful for finding the next assembly in a DAT region</td>
</tr>
</tbody>
</table>
<h3 id="numberofpatchedmethods">NumberOfPatchedMethods</h3>
<p>Should be equal to 0. Not supported in .NET nanoFramework</p>
<h3 id="paddingoftables">PaddingOfTables</h3>
<p>For every table, a number of bytes that were padded to the end of the table to align the next table to a 32bit boundary. The start of each table is aligned to a 32bit boundary, and ends at a 32bit boundary.
Some of these tables will, therefore, have no padding, and all will have values in the range [0-3]. This isn't the most compact form to hold this information, but it only costs 16 bytes/assembly. Trying to only align some of the tables is just much more hassle than it's worth. This field itself must also be aligned on a 32 bit boundary. This padding is used to compute the size of a given table (including the blob data) using the following formula:</p>
<p><code>TableSize = StartOfTables[ tableindex + 1 ] - StartOfTables[ tableindex ] - PaddingOfTables[ tableindex ]</code></p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/pe-file/AssemblyHeader.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
