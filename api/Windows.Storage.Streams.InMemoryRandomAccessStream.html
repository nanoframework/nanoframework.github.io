<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Class InMemoryRandomAccessStream | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class InMemoryRandomAccessStream | .NET nanoFramework Documentation ">
      
      <meta name="description" content="Provides random access of data in input and output streams that are stored in memory instead of on disk.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream">



  <h1 id="Windows_Storage_Streams_InMemoryRandomAccessStream" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream" class="text-break">
Class InMemoryRandomAccessStream  
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="Windows.html">Windows</a>.<a class="xref" href="Windows.Storage.html">Storage</a>.<a class="xref" href="Windows.Storage.Streams.html">Streams</a></dd></dl>
  <dl><dt>Assembly</dt><dd>Windows.Storage.Streams.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Provides random access of data in input and output streams that are stored in memory instead of on disk.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed class InMemoryRandomAccessStream : MarshalByRefObject, IRandomAccessStream, IDisposable, IInputStream, IOutputStream</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="System.Object.html">object</a></div>
      <div><a class="xref" href="System.MarshalByRefObject.html">MarshalByRefObject</a></div>
      <div><span class="xref">InMemoryRandomAccessStream</span></div>
    </dd>
  </dl>

  <dl class="typelist implements">
    <dt>Implements</dt>
    <dd>
      <div><a class="xref" href="Windows.Storage.Streams.IRandomAccessStream.html">IRandomAccessStream</a></div>
      <div><a class="xref" href="System.IDisposable.html">IDisposable</a></div>
      <div><a class="xref" href="Windows.Storage.Streams.IInputStream.html">IInputStream</a></div>
      <div><a class="xref" href="Windows.Storage.Streams.IOutputStream.html">IOutputStream</a></div>
    </dd>
  </dl>


  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ToString">object.ToString()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetHashCode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetType">object.GetType()</a>
    </div>
  </dd></dl>

  <dl class="typelist extensionMethods">
    <dt>Extension Methods</dt>
    <dd>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  </dd></dl>





  <h2 class="section" id="constructors">Constructors
</h2>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream__ctor_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.#ctor*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream__ctor" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.#ctor">
  InMemoryRandomAccessStream()
  
  </h3>

  <div class="markdown level1 summary"><p>Creates a new instance of the InMemoryRandomAccessStream class.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public InMemoryRandomAccessStream()</code></pre>
  </div>













  <h2 class="section" id="properties">Properties
</h2>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanRead_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanRead*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanRead" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanRead">
  CanRead
  
  </h3>

  <div class="markdown level1 summary"><p>Gets a value that indicates whether the stream can be read from.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanRead { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>True if the stream can be read from. Otherwise, false.</p>
</dd>
  </dl>








  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanWrite_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanWrite*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanWrite" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanWrite">
  CanWrite
  
  </h3>

  <div class="markdown level1 summary"><p>Gets a value that indicates whether the stream can be written to.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanWrite { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>True if the stream can be written to. Otherwise, false.</p>
</dd>
  </dl>








  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Length_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Length*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Length" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Length">
  Length
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the number of bytes currently in use in the buffer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Length { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt64.html">ulong</a></dt>
    <dd><p>he number of bytes currently in use in the buffer, which is less than or equal to the capacity of the buffer.</p>
</dd>
  </dl>








  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Position*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Position">
  Position
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the byte offset of the stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Position { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt64.html">ulong</a></dt>
    <dd><p>The number of bytes from the start of the stream.</p>
</dd>
  </dl>




  <h4 class="section" id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The initial offset of a IRandomAccessStream is 0.
This offset is affected by both <a class="xref" href="Windows.Storage.Streams.IInputStream.html">IInputStream</a> and <a class="xref" href="Windows.Storage.Streams.IOutputStream.html">IOutputStream</a> operations.</p>
</div>




  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Size_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Size*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Size" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Size">
  Size
  
  </h3>

  <div class="markdown level1 summary"><p>Gets or sets the size of the random access stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Size { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt64.html">ulong</a></dt>
    <dd><p>The size of the stream.</p>
</dd>
  </dl>








  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_UnstoredBufferLength_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.UnstoredBufferLength*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_UnstoredBufferLength" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.UnstoredBufferLength">
  UnstoredBufferLength
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the size of the buffer that has not been used.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint UnstoredBufferLength { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt32.html">uint</a></dt>
    <dd><p>The available buffer length, in bytes.</p>
</dd>
  </dl>








  <h2 class="section" id="methods">Methods
</h2>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Dispose_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Dispose*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Dispose" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Dispose">
  Dispose()
  
  </h3>

  <div class="markdown level1 summary"><p>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Dispose()</code></pre>
  </div>













  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Flush*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Flush">
  Flush()
  
  </h3>

  <div class="markdown level1 summary"><p>Flushes data in a sequential stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Flush()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>The stream flush operation.</p>
</dd>
  </dl>







  <h4 class="section" id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The Flush method may produce latencies and does not always guarantee durable and coherent storage of data. It's generally recommended to avoid this method if possible.
This method is specific to nanoFramework. The equivalent method in the UWP API is: FlushAsync.</p>
</div>




  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Read*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_Windows_Storage_Streams_IBuffer_System_UInt32_Windows_Storage_Streams_InputStreamOptions_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Read(Windows.Storage.Streams.IBuffer,System.UInt32,Windows.Storage.Streams.InputStreamOptions)">
  Read(IBuffer, uint, InputStreamOptions)
  
  </h3>

  <div class="markdown level1 summary"><p>Reads data from the stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint Read(IBuffer buffer, uint count, InputStreamOptions options)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="Windows.Storage.Streams.IBuffer.html">IBuffer</a></dt>
    <dd><p>A buffer that is used to return the array of bytes that are read. The return value contains the buffer that holds the results.</p>
</dd>
    <dt><code>count</code> <a class="xref" href="System.UInt32.html">uint</a></dt>
    <dd><p>The number of bytes to read that is less than or equal to the Capacity value.</p>
</dd>
    <dt><code>options</code> <a class="xref" href="Windows.Storage.Streams.InputStreamOptions.html">InputStreamOptions</a></dt>
    <dd><p>Specifies the type of the asynchronous read operation.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt32.html">uint</a></dt>
    <dd><p>The number of bytes that were actually read.</p>
</dd>
  </dl>







  <h4 class="section" id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_Windows_Storage_Streams_IBuffer_System_UInt32_Windows_Storage_Streams_InputStreamOptions__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is specific to nanoFramework. The equivalent method in the UWP API is: ReadAsync(IBuffer buffer, UInt32 count, InputStreamOptions options).</p>
</div>




  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Seek*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_System_UInt64_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Seek(System.UInt64)">
  Seek(ulong)
  
  </h3>

  <div class="markdown level1 summary"><p>Sets the position of the stream to the specified value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Seek(ulong position)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>position</code> <a class="xref" href="System.UInt64.html">ulong</a></dt>
    <dd><p>The new position of the stream.</p>
</dd>
  </dl>








  <h4 class="section" id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_System_UInt64__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>Warning! This method does not check the position to make sure the value is valid for the stream. If the position is invalid for the stream, the ReadAsync and WriteAsync methods will return an error if you call them.</p>
</div>




  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Store_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Store*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Store" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Store">
  Store()
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint Store()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.UInt32.html">uint</a></dt>
    <dd></dd>
  </dl>











  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Write*"></a>

  <h3 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_System_Byte___" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Write(System.Byte[])">
  Write(byte[])
  
  </h3>

  <div class="markdown level1 summary"><p>Writes data in a sequential stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Write(byte[] buffer)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>A buffer that contains the data to be written.</p>
</dd>
  </dl>








  <h4 class="section" id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_System_Byte____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is specific to nanoFramework. The equivalent method in the UWP API is: WriteAsync.</p>
</div>





</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
