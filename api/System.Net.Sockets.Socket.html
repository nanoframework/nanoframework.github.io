<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Class Socket
 | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class Socket
 | .NET nanoFramework Documentation ">
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="System.Net.Sockets.Socket">



  <h1 id="System_Net_Sockets_Socket" data-uid="System.Net.Sockets.Socket" class="text-break">
    Class Socket
  
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="https://learn.microsoft.com/dotnet/api/system">System</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net">Net</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net.sockets">Sockets</a></dd></dl>
  <dl><dt>Assembly</dt><dd>System.Net.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Implements the Berkeley sockets interface.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class Socket : IDisposable</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="System.Object.html">object</a></div>
      <div><span class="xref">Socket</span></div>
    </dd>
  </dl>

  <dl class="typelist implements">
    <dt>Implements</dt>
    <dd>
      <div><a class="xref" href="System.IDisposable.html">IDisposable</a></div>
    </dd>
  </dl>


  <dl class="typelist derived">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ToString">object.ToString()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetHashCode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetType">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">object.MemberwiseClone()</a>
    </div>
  </dd></dl>

  <dl class="typelist extensionMethods">
    <dt>Extension Methods</dt>
    <dd>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  </dd></dl>





  <h2 class="section" id="constructors">Constructors
</h2>


  <a id="System_Net_Sockets_Socket__ctor_" data-uid="System.Net.Sockets.Socket.#ctor*"></a>

  <h3 id="System_Net_Sockets_Socket__ctor_System_Net_Sockets_AddressFamily_System_Net_Sockets_SocketType_System_Net_Sockets_ProtocolType_" data-uid="System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
  Socket(AddressFamily, SocketType, ProtocolType)
  
  </h3>

  <div class="markdown level1 summary"><p>Initializes a new instance of the Socket class using the specified address family, socket type and protocol.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>addressFamily</code> <a class="xref" href="System.Net.Sockets.AddressFamily.html">AddressFamily</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.AddressFamily.html">AddressFamily</a> values.</p>
</dd>
    <dt><code>socketType</code> <a class="xref" href="System.Net.Sockets.SocketType.html">SocketType</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SocketType">SocketType</a> values.</p>
</dd>
    <dt><code>protocolType</code> <a class="xref" href="System.Net.Sockets.ProtocolType.html">ProtocolType</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.ProtocolType.html">ProtocolType</a> values.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket__ctor_System_Net_Sockets_AddressFamily_System_Net_Sockets_SocketType_System_Net_Sockets_ProtocolType__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The addressFamily parameter specifies the addressing scheme that the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> class uses, the socketType parameter specifies the type of the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> class,
and the protocolType parameter specifies the protocol used by <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. The three parameters are not independent. Some address families restrict which
protocols can be used with them, and often the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> type is implicit in the protocol. If the combination of address family, <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> type, and protocol type
esults in an invalid Socket, this constructor throws a SocketException.</p>
</div>




  <h2 class="section" id="properties">Properties
</h2>


  <a id="System_Net_Sockets_Socket_Available_" data-uid="System.Net.Sockets.Socket.Available*"></a>

  <h3 id="System_Net_Sockets_Socket_Available" data-uid="System.Net.Sockets.Socket.Available">
  Available
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the amount of data that has been received from the network and is available to be read.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Available { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>An integer error code that is associated with this exception.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_Available_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If you are using a non-blocking <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> is a good way to determine whether data is queued for reading, before calling <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a>. The available data
is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> returns 0.
</p>
<p>
If the remote host shuts down or closes the connection, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> can throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the 
<a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API 
error code documentation in the MSDN library for a detailed description of the error.
</p>
</div>




  <a id="System_Net_Sockets_Socket_LocalEndPoint_" data-uid="System.Net.Sockets.Socket.LocalEndPoint*"></a>

  <h3 id="System_Net_Sockets_Socket_LocalEndPoint" data-uid="System.Net.Sockets.Socket.LocalEndPoint">
  LocalEndPoint
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the local endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public EndPoint LocalEndPoint { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The EndPoint that the Socket is using for communications.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_LocalEndPoint_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
The LocalEndPoint property gets an <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that contains the local IP address and port number to which your <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is bound. You must cast this 
<a class="xref" href="System.Net.EndPoint.html">EndPoint</a> to an <a class="xref" href="System.Net.IPEndPoint.html">IPEndPoint</a> before retrieving any information. You can then call the <a class="xref" href="System.Net.IPEndPoint.html#System_Net_IPEndPoint_Address">Address</a> method to retrieve the local <a class="xref" href="System.Net.IPAddress.html">IPAddress</a>, and the 
<a class="xref" href="System.Net.IPEndPoint.html#System_Net_IPEndPoint_Port">Port</a> method to retrieve the local port number.
</p>
<p>
The LocalEndPoint property is usually set after you make a call to the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Bind_System_Net_EndPoint_">Bind(EndPoint)</a> method. If you allow the system to assign your socket's local IP address and
port number, the LocalEndPoint property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call 
to the Connect or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.
</p>
</div>




  <a id="System_Net_Sockets_Socket_ReceiveTimeout_" data-uid="System.Net.Sockets.Socket.ReceiveTimeout*"></a>

  <h3 id="System_Net_Sockets_Socket_ReceiveTimeout" data-uid="System.Net.Sockets.Socket.ReceiveTimeout">
  ReceiveTimeout
  
  </h3>

  <div class="markdown level1 summary"><p>Gets or sets a value that specifies the amount of time after which a synchronous <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> call will time out.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ReceiveTimeout { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_ReceiveTimeout_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This option applies to synchronous <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> calls only. If the time-out period is exceeded, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.</p>
</div>




  <a id="System_Net_Sockets_Socket_RemoteEndPoint_" data-uid="System.Net.Sockets.Socket.RemoteEndPoint*"></a>

  <h3 id="System_Net_Sockets_Socket_RemoteEndPoint" data-uid="System.Net.Sockets.Socket.RemoteEndPoint">
  RemoteEndPoint
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the remote endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public EndPoint RemoteEndPoint { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> with which the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is communicating.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_RemoteEndPoint_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If you are using a connection-oriented protocol, the RemoteEndPoint property gets the <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that contains the remote IP address and port number to
which the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is connected. If you are using a connectionless protocol, RemoteEndPoint contains the default remote IP address and port number with 
which the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> will communicate. You must cast this <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> to an <a class="xref" href="System.Net.IPEndPoint.html">IPEndPoint</a> before retrieving any information. You can then call the 
<a class="xref" href="System.Net.IPEndPoint.html#System_Net_IPEndPoint_Address">Address</a> method to retrieve the remote <a class="xref" href="System.Net.IPAddress.html">IPAddress</a>, and the <a class="xref" href="System.Net.IPEndPoint.html#System_Net_IPEndPoint_Port">Port</a> method to retrieve the remote port number.
</p>
<p>
The RemoteEndPoint is set after a call to either <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a>. If you try to access this property earlier, RemoteEndPoint will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. 
If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer
to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.
</p>
</div>




  <a id="System_Net_Sockets_Socket_SendTimeout_" data-uid="System.Net.Sockets.Socket.SendTimeout*"></a>

  <h3 id="System_Net_Sockets_Socket_SendTimeout" data-uid="System.Net.Sockets.Socket.SendTimeout">
  SendTimeout
  
  </h3>

  <div class="markdown level1 summary"><p>Gets or sets a value that specifies the amount of time after which a synchronous <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> call will time out.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int SendTimeout { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The time-out value, in milliseconds. If you set the property with a value between 1 and 499,
the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_SendTimeout_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This option applies to synchronous <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> calls only. If the time-out period is exceeded, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> method will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.</p>
</div>




  <a id="System_Net_Sockets_Socket_SocketType_" data-uid="System.Net.Sockets.Socket.SocketType*"></a>

  <h3 id="System_Net_Sockets_Socket_SocketType" data-uid="System.Net.Sockets.Socket.SocketType">
  SocketType
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the type of the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public SocketType SocketType { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Net.Sockets.SocketType.html">SocketType</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SocketType">SocketType</a> values.</p>
</dd>
  </dl>




  <h4 class="section" id="System_Net_Sockets_Socket_SocketType_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SocketType">SocketType</a> is read-only and is set when the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is created.</p>
</div>




  <h2 class="section" id="methods">Methods
</h2>


  <a id="System_Net_Sockets_Socket_Accept_" data-uid="System.Net.Sockets.Socket.Accept*"></a>

  <h3 id="System_Net_Sockets_Socket_Accept" data-uid="System.Net.Sockets.Socket.Accept">
  Accept()
  
  </h3>

  <div class="markdown level1 summary"><p>Creates a new <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> for a newly created connection.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Socket Accept()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a></dt>
    <dd><p>A <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> for a newly created connection.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Accept_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>Accept synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and 
returns a new <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. You cannot use this returned <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> to accept any additional connections from the connection queue. However, you can call the 
<a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_RemoteEndPoint">RemoteEndPoint</a> method of the returned <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> to identify the remote host's network address and port number.
</p>
<p>
<code>Before calling the Accept method, you must first call the Listen method to listen for and queue incoming connection requests.</code>
</p>
</div>




  <a id="System_Net_Sockets_Socket_Bind_" data-uid="System.Net.Sockets.Socket.Bind*"></a>

  <h3 id="System_Net_Sockets_Socket_Bind_System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
  Bind(EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Associates a <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> with a local endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Bind(EndPoint localEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>localEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The local <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> to associate with the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_Bind_System_Net_EndPoint__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Use the Bind method if you need to use a specific local endpoint. You must call Bind before you can call the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Listen_System_Int32_">Listen(int)</a> method. You do not need to call Bind
before using the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> method unless you need to use a specific local endpoint. You can use the Bind method on both connectionless and 
connection-oriented protocols.
</p>
<p>
Before calling Bind, you must first create the local <a class="xref" href="System.Net.IPEndPoint.html">IPEndPoint</a> from which you intend to communicate data. If you do not care which local address is
assigned, you can create an <a class="xref" href="System.Net.IPEndPoint.html">IPEndPoint</a> using <a class="xref" href="System.Net.IPAddress.html#System_Net_IPAddress_Any">Any</a> as the address parameter, and the underlying service provider will assign the most 
appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port 
is used, you can create an <a class="xref" href="System.Net.IPEndPoint.html">IPEndPoint</a> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.
</p>
<p>
If you use the above approach, you can discover what local network address and port number has been assigned by calling the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_LocalEndPoint">LocalEndPoint</a>. If you are using a 
connection-oriented protocol, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_LocalEndPoint">LocalEndPoint</a> will not return the locally assigned network address until after you have made a call to the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> method. If 
you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.
</p>
<code>If you intend to receive multicast datagrams, you must call the Bind method with a multicast port number.</code>
<code>You must call the Bind method if you intend to receive connectionless datagrams using the ReceiveFrom method.</code>
</div>




  <a id="System_Net_Sockets_Socket_Close_" data-uid="System.Net.Sockets.Socket.Close*"></a>

  <h3 id="System_Net_Sockets_Socket_Close" data-uid="System.Net.Sockets.Socket.Close">
  Close()
  
  </h3>

  <div class="markdown level1 summary"><p>Closes the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> connection and releases all associated resources.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Close()</code></pre>
  </div>









  <h4 class="section" id="System_Net_Sockets_Socket_Close_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The Close method closes the remote host connection and releases all managed and unmanaged resources associated with the Socket.
Upon closing, the Connected property is set to false.</p>
</div>




  <a id="System_Net_Sockets_Socket_Connect_" data-uid="System.Net.Sockets.Socket.Connect*"></a>

  <h3 id="System_Net_Sockets_Socket_Connect_System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
  Connect(EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Establishes a connection to a remote host.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Connect(EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>An <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the remote device.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_Connect_System_Net_EndPoint__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If you are using a connection-oriented protocol such as TCP, the Connect method synchronously establishes a network connection between <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_LocalEndPoint">LocalEndPoint</a>
and the specified remote endpoint. If you are using a connectionless protocol, Connect establishes a default remote host. After you call Connect, you can 
send data to the remote device with the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> method, or receive data from the remote device with the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method.
</p>
<p>
If you are using a connectionless protocol such as UDP, you do not have to call Connect before sending and receiving data. You can use <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_EndPoint_">SendTo(byte[], EndPoint)</a> and 
<a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> to synchronously communicate with a remote host. If you do call Connect, any datagrams that arrive from an address other than the 
specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Boolean_">SetSocketOption(SocketOptionLevel, SocketOptionName, bool)</a> method and 
set the socket option to <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_Broadcast">Broadcast</a>, or Connect will throw a SocketException. If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the 
<a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API 
error code documentation in the MSDN library for a detailed description of the error.
</p>
<p>
<code>
If you are using a connection-oriented protocol and did not call Bind before calling Connect, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. 
If you want to change the default remote host, call Connect again with the desired endpoint.
</code>
</p>
</div>




  <a id="System_Net_Sockets_Socket_Dispose_" data-uid="System.Net.Sockets.Socket.Dispose*"></a>

  <h3 id="System_Net_Sockets_Socket_Dispose_System_Boolean_" data-uid="System.Net.Sockets.Socket.Dispose(System.Boolean)">
  Dispose(bool)
  
  </h3>

  <div class="markdown level1 summary"><p>Releases the unmanaged resources used by the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>, and optionally disposes of the managed resources.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected virtual void Dispose(bool disposing)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>disposing</code> <a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>true to release both managed and unmanaged resources; false to releases only unmanaged resources.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_Dispose_System_Boolean__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is called by the public Dispose() method and the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Finalize">Finalize()</a> method. Dispose() invokes the protected Dispose(Boolean) method with the 
disposing parameter set to true. <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Finalize">Finalize()</a> invokes Dispose with disposing set to false.
</p>
<p>
When the disposing parameter is true, this method releases all resources held by any managed objects that this Socket references. This method invokes the Dispose() method of each referenced object.
</p>
</div>




  <a id="System_Net_Sockets_Socket_Finalize_" data-uid="System.Net.Sockets.Socket.Finalize*"></a>

  <h3 id="System_Net_Sockets_Socket_Finalize" data-uid="System.Net.Sockets.Socket.Finalize">
  Finalize()
  
  </h3>

  <div class="markdown level1 summary"><p>Deconstructor</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override void Finalize()</code></pre>
  </div>













  <a id="System_Net_Sockets_Socket_GetSocketOption_" data-uid="System.Net.Sockets.Socket.GetSocketOption*"></a>

  <h3 id="System_Net_Sockets_Socket_GetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_" data-uid="System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
  GetSocketOption(SocketOptionLevel, SocketOptionName)
  
  </h3>

  <div class="markdown level1 summary"><p>Returns the value of a <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>optionLevel</code> <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a> values.</p>
</dd>
    <dt><code>optionName</code> <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> values.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Object.html">object</a></dt>
    <dd><p>/// An object that represents the value of the option.</p>
<p>
When the <code class="paramref">optionName</code> parameter is set to <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_Linger">Linger</a> the return value is an <a class="xref" href="System.Int32.html">int</a> with the value in seconds that the socket will linger after close.
To check if linger is enabled for the socket the <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_DontLinger">DontLinger</a> option should be queried.
</p>
<p>
When optionName is set to <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_ExclusiveAddressUse">ExclusiveAddressUse</a>, <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_DontLinger">DontLinger</a>, <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_AcceptConnection">AcceptConnection</a>, <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_Broadcast">Broadcast</a> or <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_KeepAlive">KeepAlive</a>, the return value is <a class="xref" href="System.Boolean.html">bool</a>.
</p>
<p>
When optionName is any other value, the return value is an integer.
</p>
</dd>
  </dl>








  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.NotSupportedException.html">NotSupportedException</a></dt>
    <dd><p>When using an <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> that can't be retrieved.</p>
</dd>
  </dl>



  <a id="System_Net_Sockets_Socket_GetSocketOption_" data-uid="System.Net.Sockets.Socket.GetSocketOption*"></a>

  <h3 id="System_Net_Sockets_Socket_GetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Byte___" data-uid="System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
  GetSocketOption(SocketOptionLevel, SocketOptionName, byte[])
  
  </h3>

  <div class="markdown level1 summary"><p>Returns the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option setting, represented as a byte array.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] val)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>optionLevel</code> <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a> values.</p>
</dd>
    <dt><code>optionName</code> <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> values.</p>
</dd>
    <dt><code>val</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type <a class="xref" href="System.Byte.html">byte</a> that is to receive the option setting.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_GetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Byte____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> options determine the behavior of the current <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. Upon successful completion of this method, the array specified by the val parameter contains the value of the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option.
</p>
<p>
When the length of the val array is smaller than the number of bytes required to store the value of the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_GetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_">GetSocketOption(SocketOptionLevel, SocketOptionName)</a> will 
throw a SocketException. If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you 
have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. 
Use this overload for any sockets that are represented by Boolean values or integers.
</p>
</div>




  <a id="System_Net_Sockets_Socket_Listen_" data-uid="System.Net.Sockets.Socket.Listen*"></a>

  <h3 id="System_Net_Sockets_Socket_Listen_System_Int32_" data-uid="System.Net.Sockets.Socket.Listen(System.Int32)">
  Listen(int)
  
  </h3>

  <div class="markdown level1 summary"><p>Places a <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> in a listening state.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Listen(int backlog)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>backlog</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The maximum length of the pending connections queue.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_Listen_System_Int32__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Listen causes a connection-oriented <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> to listen for incoming connection attempts. The backlog parameter specifies the number of incoming 
connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_MaxConnections">MaxConnections</a> value. 
Listen does not block.
</p>
<p>
If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the 
Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> or BeginAccept 
to accept a connection from the queue.
</p>
<p>
<code>You must call the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Bind_System_Net_EndPoint_">Bind(EndPoint)</a> method before calling Listen, or Listen will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.</code>
</p>
</div>




  <a id="System_Net_Sockets_Socket_Poll_" data-uid="System.Net.Sockets.Socket.Poll*"></a>

  <h3 id="System_Net_Sockets_Socket_Poll_System_Int32_System_Net_Sockets_SelectMode_" data-uid="System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
  Poll(int, SelectMode)
  
  </h3>

  <div class="markdown level1 summary"><p>Determines the status of the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Poll(int microSeconds, SelectMode mode)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>microSeconds</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The time to wait for a response, in microseconds.</p>
</dd>
    <dt><code>mode</code> <a class="xref" href="System.Net.Sockets.SelectMode.html">SelectMode</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SelectMode.html">SelectMode</a> values.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>The status of the Socket based on the polling mode value passed in the mode parameter.</p>
<ul><li><span class="term"><a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectRead">SelectRead</a></span><span class="term"><a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectWrite">SelectWrite</a></span><span class="term"><a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectError">SelectError</a></span>
<p>true if Listen has been called and a connection is pending;</p>
<p>-or-</p>
<p>true if data is available for reading;</p>
<p>-or-</p>
<p>true if the connection has been closed, reset, or terminated; otherwise, returns false.</p>
<p>true , if processing a Connect, and the connection has succeeded;</p>
<p>-or-</p>
<p>true if data can be sent; otherwise, returns false.</p>
<p>true if processing a <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> that does not block, and the connection has failed;</p>
<p>-or-</p>
<p>true if <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_OutOfBandInline">OutOfBandInline</a> is not set and out-of-band data is available; otherwise, returns false.</p>
</li></ul>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Poll_System_Int32_System_Net_Sockets_SelectMode__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
The Poll method will check the state of the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. Specify <a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectRead">SelectRead</a> for the selectMode parameter to determine if the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is readable. 
Specify <a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectWrite">SelectWrite</a> to determine if the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> is writable. Use <a class="xref" href="System.Net.Sockets.SelectMode.html#System_Net_Sockets_SelectMode_SelectError">SelectError</a> to detect an error condition. Poll will block execution 
until the specified time period, measured in microseconds, elapses. Set the microSeconds parameter to a negative integer if you would like to wait 
indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the Select method.
</p>
<p>
If you receive a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.
</p>
</div>




  <a id="System_Net_Sockets_Socket_Receive_" data-uid="System.Net.Sockets.Socket.Receive*"></a>

  <h3 id="System_Net_Sockets_Socket_Receive_System_Byte___" data-uid="System.Net.Sockets.Socket.Receive(System.Byte[])">
  Receive(byte[])
  
  </h3>

  <div class="markdown level1 summary"><p>Receives data from a bound <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> into a receive buffer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Receive(byte[] buffer)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for the received data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Receive_System_Byte____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> from both connection-oriented 
and connectionless sockets.
</p>
<p>
This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the 
<a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> value defaults to <a class="xref" href="System.Net.Sockets.SocketFlags.html#System_Net_Sockets_SocketFlags_None">None</a>.
</p>
<p>
If no data is available for reading, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method will block until data is available, unless a time-out value was set by using <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveTimeout">ReceiveTimeout</a>. If 
the time-out value was exceeded, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> call will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method will complete immediately and throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. You can use the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> property to 
determine if data is available for reading. When <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> is non-zero, retry the receive operation.
</p>
<p>If you are using a connectionless <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> will read the first queued datagram from the destination address you specify in the Connect method. If 
the datagram you receive is larger than the size of the buffer parameter, buffer gets filled with the first part of the message, the excess data is lost and a 
SocketException is thrown.
</p>
</div>




  <a id="System_Net_Sockets_Socket_Receive_" data-uid="System.Net.Sockets.Socket.Receive*"></a>

  <h3 id="System_Net_Sockets_Socket_Receive_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
  Receive(byte[], int, int, SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives the specified number of bytes from a bound <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> into the specified offset position of the receive buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for the received data.</p>
</dd>
    <dt><code>offset</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The location in buffer to store the received data.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to receive.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Receive_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> from both connection-
oriented and connectionless sockets.</p>
</div>




  <a id="System_Net_Sockets_Socket_Receive_" data-uid="System.Net.Sockets.Socket.Receive*"></a>

  <h3 id="System_Net_Sockets_Socket_Receive_System_Byte___System_Int32_System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
  Receive(byte[], int, SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives the specified number of bytes of data from a bound <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> into a receive buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Receive(byte[] buffer, int size, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for the received data.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to receive.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Receive_System_Byte___System_Int32_System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call Receive from 
both connection-oriented and connectionless sockets.</p>
<p>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
<p>If no data is available for reading, the Receive method will block until data is available, unless a time-out value was set by using 
<a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveTimeout">ReceiveTimeout</a>. If the time-out value was exceeded, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> call will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you are in non-blocking 
mode, and there is no data available in the in the protocol stack buffer, The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method will complete immediately and throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. 
You can use the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> property to determine if data is available for reading. When <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> is non-zero, retry your receive operation.</p>
</div>




  <a id="System_Net_Sockets_Socket_Receive_" data-uid="System.Net.Sockets.Socket.Receive*"></a>

  <h3 id="System_Net_Sockets_Socket_Receive_System_Byte___System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
  Receive(byte[], SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives data from a bound <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> into a receive buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Receive(byte[] buffer, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for the received data.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Receive_System_Byte___System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Receive_System_Byte___">Receive(byte[])</a> from both connection-oriented 
and connectionless sockets.</p>
<p>
This overload only requires you to provide a receive buffer and the necessary <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.
</p>
</div>




  <a id="System_Net_Sockets_Socket_ReceiveFrom_" data-uid="System.Net.Sockets.Socket.ReceiveFrom*"></a>

  <h3 id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__" data-uid="System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
  ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>, and stores the endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type <a class="xref" href="System.Byte.html">byte</a> that is the storage location for received data.</p>
</dd>
    <dt><code>offset</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The position in the buffer parameter to store the received data.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to receive.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>An <a class="xref" href="System.Net.EndPoint.html">EndPoint</a>, passed by reference, that represents the remote server.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method reads data into the buffer parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</p>
<p>With connectionless protocols, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> will read the first enqueued datagram received into the local network buffer.If the datagram you receive is larger than the size of buffer, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method will fill buffer with as much of the message as is possible, and throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.If you are using an unreliable protocol, the excess data will be lost.If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method with a large enough buffer.</p>
<p>If no data is available for reading, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method will block until data is available.If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method will complete immediately and throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. You can use the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> property to determine if data is available for reading. When <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Available">Available</a> is non-zero, retry the receive operation.</p>
<p>Although <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> is intended for connectionless protocols, you can use a connection-oriented protocol as well.If you choose to do so, you must first either establish a remote host connection by calling the Connect method or accept an incoming remote host connection by calling the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method. If you do not establish or accept a connection before calling the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method, you will get a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.You can also establish a default remote host for a connectionless protocol prior to calling the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method.In either of these cases, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method will ignore the remoteEP parameter and only receive data from the connected or default remote host.</p>
<p>With connection-oriented sockets, <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> will read as much data as is available up to the amount of bytes specified by the size parameter. If the remote host shuts down the Socket connection with the Shutdown method, and all available data has been Received, the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__">ReceiveFrom(byte[], int, int, SocketFlags, ref EndPoint)</a> method will complete immediately and return zero bytes.</p>
</div>




  <a id="System_Net_Sockets_Socket_ReceiveFrom_" data-uid="System.Net.Sockets.Socket.ReceiveFrom*"></a>

  <h3 id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint__" data-uid="System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
  ReceiveFrom(byte[], int, SocketFlags, ref EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives the specified number of bytes into the data buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>, and stores the endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ReceiveFrom(byte[] buffer, int size, SocketFlags socketFlags, ref EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for received data.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to receive.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>An <a class="xref" href="System.Net.EndPoint.html">EndPoint</a>, passed by reference, that represents the remote server.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>











  <a id="System_Net_Sockets_Socket_ReceiveFrom_" data-uid="System.Net.Sockets.Socket.ReceiveFrom*"></a>

  <h3 id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Net_EndPoint__" data-uid="System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
  ReceiveFrom(byte[], ref EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives a datagram into the data buffer and stores the endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for received data.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>An <a class="xref" href="System.Net.EndPoint.html">EndPoint</a>, passed by reference, that represents the remote server.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Net_EndPoint___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>The <see cref="o:ReceiveFrom"></see> method reads data into the buffer parameter, returns the number of bytes successfully read, 
and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive 
connectionless datagrams from an unknown host or multiple hosts.</p>
<p>This overload only requires you to provide a receive buffer, and an EndPoint that represents the remote host.
The buffer offset defaults to 0. The size defaults to the length of the buffer parameter and the socketFlags value 
defaults to None.
</p>
<div class="IMPORTANT"><h5>important</h5><p>
Before calling <see cref="o:ReceiveFrom"></see>, you must explicitly <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Bind_System_Net_EndPoint_">Bind(EndPoint)</a> the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> to a local endpoint using the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Bind_System_Net_EndPoint_">Bind(EndPoint)</a> method. If you do not, <see cref="o:ReceiveFrom"></see> will 
throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>.
</p></div>
<div class="IMPORTANT"><h5>important</h5><p>
The <a class="xref" href="System.Net.Sockets.AddressFamily.html">AddressFamily</a> of the <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> used in <see cref="o:ReceiveFrom"></see> needs to match the <a class="xref" href="System.Net.Sockets.AddressFamily.html">AddressFamily</a> of the <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> used in <see cref="o:SendTo"></see>.
</p></div>
</div>




  <a id="System_Net_Sockets_Socket_ReceiveFrom_" data-uid="System.Net.Sockets.Socket.ReceiveFrom*"></a>

  <h3 id="System_Net_Sockets_Socket_ReceiveFrom_System_Byte___System_Net_Sockets_SocketFlags_System_Net_EndPoint__" data-uid="System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
  ReceiveFrom(byte[], SocketFlags, ref EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Receives a datagram into the data buffer, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>, and stores the endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ReceiveFrom(byte[] buffer, SocketFlags socketFlags, ref EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that is the storage location for received data.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>An <a class="xref" href="System.Net.EndPoint.html">EndPoint</a>, passed by reference, that represents the remote server.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes received.</p>
</dd>
  </dl>











  <a id="System_Net_Sockets_Socket_Send_" data-uid="System.Net.Sockets.Socket.Send*"></a>

  <h3 id="System_Net_Sockets_Socket_Send_System_Byte___" data-uid="System.Net.Sockets.Socket.Send(System.Byte[])">
  Send(byte[])
  
  </h3>

  <div class="markdown level1 summary"><p>Sends data to a connected <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Send(byte[] buffer)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent to the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Send_System_Byte____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> synchronously sends data to the remote host specified in the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method and returns the number of bytes successfully sent. <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> 
can be used for both connection-oriented and connectionless protocols.</p>
<p>This overload requires a buffer that contains the data you want to send. The <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</p>
<p>If you are using a connectionless protocol, you must call <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> before calling this method, or <see cref="o:Send"></see> will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you are using a connection-oriented protocol, you must either 
use <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> to establish a remote host connection, or use <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> to accept an incoming connection.</p>
<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_EndPoint_">SendTo(byte[], EndPoint)</a> method. If you do not use the 
SendTo method, you will have to call Connect before each call to Send. You can use SendTo even after you have established a default remote host with 
Connect. You can also change the default remote host prior to calling Send by making another call to Connect.</p>
<p>
If you are using a connection-oriented protocol, <see cref="o:SendTo()"></see> will block until all of the bytes in the buffer are sent, unless a time-out was set by using 
<a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SendTimeout">SendTimeout</a>. If the time-out value was exceeded, the <see cref="o:SendTo()"></see> call will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. In nonblocking mode, Send may complete 
successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and 
to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network 
immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A 
successful completion of the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Send_System_Byte___">Send(byte[])</a> method means that the underlying system has had room to buffer your data for a network send.
</p>
<div class="IMPORTANT"><h5>important</h5><p>
If you receive a SocketException, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, 
refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.
</p></div>
<div class="IMPORTANT"><h5>important</h5><p>
The successful completion of a send does not indicate that the data was successfully delivered. 
If no buffer space is available within the transport system to hold the data to be transmitted, 
send will block unless the socket has been placed in nonblocking mode.
</p></div>
</div>


  <dl class="typelist seealso">
    <dt>See Also</dt>
    <dd>
    <div><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a></div>
    <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system">System</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net">Net</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net.sockets">Sockets</a></div>
    </dd>
  </dl>


  <a id="System_Net_Sockets_Socket_Send_" data-uid="System.Net.Sockets.Socket.Send*"></a>

  <h3 id="System_Net_Sockets_Socket_Send_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
  Send(byte[], int, int, SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends the specified number of bytes of data to a connected <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>, starting at the specified offset, and using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent</p>
</dd>
    <dt><code>offset</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd></dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd></dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent to the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Send_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><see cref="o:Send()"></see> synchronously sends data to the remote host specified in the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method and returns the number of bytes successfully sent. <see cref="o:Send()"></see> 
can be used for both connection-oriented and connectionless protocols.</p>
<p>In this overload, if you specify the <a class="xref" href="System.Net.Sockets.SocketFlags.html#System_Net_Sockets_SocketFlags_DontRoute">DontRoute</a> flag as the socketflags parameter, the data you are sending will not be routed.</p>
<div class="IMPORTANT"><h5>important</h5><p>
The successful completion of a send does not indicate that the data was successfully delivered. 
If no buffer space is available within the transport system to hold the data to be transmitted, 
send will block unless the socket has been placed in nonblocking mode.
</p></div>
</div>


  <dl class="typelist seealso">
    <dt>See Also</dt>
    <dd>
    <div><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a></div>
    <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system">System</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net">Net</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net.sockets">Sockets</a></div>
    </dd>
  </dl>


  <a id="System_Net_Sockets_Socket_Send_" data-uid="System.Net.Sockets.Socket.Send*"></a>

  <h3 id="System_Net_Sockets_Socket_Send_System_Byte___System_Int32_System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
  Send(byte[], int, SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends the specified number of bytes of data to a connected <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>, using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Send(byte[] buffer, int size, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd></dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent to the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Send_System_Byte___System_Int32_System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><see cref="o:Send()"></see> synchronously sends data to the remote host specified in the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method and returns the number of bytes successfully sent. <see cref="o:Send()"></see> 
can be used for both connection-oriented and connectionless protocols.</p>
<p>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, 
and a bitwise combination of any <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>. If you specify the <a class="xref" href="System.Net.Sockets.SocketFlags.html#System_Net_Sockets_SocketFlags_DontRoute">DontRoute</a> flag as the socketflags parameter, the data you are sending will not be routed.</p>
<div class="IMPORTANT"><h5>important</h5><p>
You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. 
If it does, the datagram will not be sent and <see cref="o:Send"></see> will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you receive a 
<a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.
</p></div>
<div class="IMPORTANT"><h5>important</h5><p>
The successful completion of a send does not indicate that the data was successfully delivered. 
If no buffer space is available within the transport system to hold the data to be transmitted, 
send will block unless the socket has been placed in nonblocking mode.
</p></div>
</div>


  <dl class="typelist seealso">
    <dt>See Also</dt>
    <dd>
    <div><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a></div>
    <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system">System</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net">Net</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net.sockets">Sockets</a></div>
    </dd>
  </dl>


  <a id="System_Net_Sockets_Socket_Send_" data-uid="System.Net.Sockets.Socket.Send*"></a>

  <h3 id="System_Net_Sockets_Socket_Send_System_Byte___System_Net_Sockets_SocketFlags_" data-uid="System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
  Send(byte[], SocketFlags)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends data to a connected <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Send(byte[] buffer, SocketFlags socketFlags)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent to the <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_Send_System_Byte___System_Net_Sockets_SocketFlags__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><see cref="o:Send()"></see> synchronously sends data to the remote host specified in the <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Connect_System_Net_EndPoint_">Connect(EndPoint)</a> or <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_Accept">Accept()</a> method and returns the number of bytes successfully sent. <see cref="o:Send()"></see> 
can be used for both connection-oriented and connectionless protocols.</p>
<p>his overload requires a buffer that contains the data you want to send and a bitwise combination of SocketFlags. 
The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the 
DontRoute flag as the socketflags parameter value, the data you are sending will not be routed.
</p>
<div class="IMPORTANT"><h5>important</h5><p>
You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. 
If it does, the datagram will not be sent and <see cref="o:Send"></see> will throw a <a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>. If you receive a 
<a class="xref" href="System.Net.Sockets.SocketException.html">SocketException</a>, use the <a class="xref" href="System.Net.Sockets.SocketException.html#System_Net_Sockets_SocketException_ErrorCode">ErrorCode</a> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.
</p></div>
<div class="IMPORTANT"><h5>important</h5><p>
The successful completion of a send does not indicate that the data was successfully delivered. 
If no buffer space is available within the transport system to hold the data to be transmitted, 
send will block unless the socket has been placed in nonblocking mode.
</p></div>
</div>


  <dl class="typelist seealso">
    <dt>See Also</dt>
    <dd>
    <div><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a></div>
    <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system">System</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net">Net</a>.<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.net.sockets">Sockets</a></div>
    </dd>
  </dl>


  <a id="System_Net_Sockets_Socket_SendTo_" data-uid="System.Net.Sockets.Socket.SendTo*"></a>

  <h3 id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
  SendTo(byte[], int, int, SocketFlags, EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends data to the specified endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent.</p>
</dd>
    <dt><code>offset</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the destination for the data.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to send.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the destination location for the data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent.</p>
</dd>
  </dl>











  <a id="System_Net_Sockets_Socket_SendTo_" data-uid="System.Net.Sockets.Socket.SendTo*"></a>

  <h3 id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
  SendTo(byte[], int, SocketFlags, EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends the specified number of bytes of data to the specified endpoint using the specified SocketFlags.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int SendTo(byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent.</p>
</dd>
    <dt><code>size</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes to send.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the destination location for the data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent.</p>
</dd>
  </dl>











  <a id="System_Net_Sockets_Socket_SendTo_" data-uid="System.Net.Sockets.Socket.SendTo*"></a>

  <h3 id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
  SendTo(byte[], EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends data to the specified endpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int SendTo(byte[] buffer, EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>n array of type Byte that contains the data to be sent.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the destination location for the data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_EndPoint__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the buffer parameter, and the SocketFlags value defaults to 0.</p>
</div>




  <a id="System_Net_Sockets_Socket_SendTo_" data-uid="System.Net.Sockets.Socket.SendTo*"></a>

  <h3 id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_Sockets_SocketFlags_System_Net_EndPoint_" data-uid="System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
  SendTo(byte[], SocketFlags, EndPoint)
  
  </h3>

  <div class="markdown level1 summary"><p>Sends data to a specific endpoint using the specified <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>buffer</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that contains the data to be sent.</p>
</dd>
    <dt><code>socketFlags</code> <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a></dt>
    <dd><p>A bitwise combination of the <a class="xref" href="System.Net.Sockets.SocketFlags.html">SocketFlags</a> values.</p>
</dd>
    <dt><code>remoteEP</code> <a class="xref" href="System.Net.EndPoint.html">EndPoint</a></dt>
    <dd><p>The <a class="xref" href="System.Net.EndPoint.html">EndPoint</a> that represents the destination location for the data.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>The number of bytes sent.</p>
</dd>
  </dl>







  <h4 class="section" id="System_Net_Sockets_Socket_SendTo_System_Byte___System_Net_Sockets_SocketFlags_System_Net_EndPoint__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <a class="xref" href="System.Net.Sockets.SocketFlags.html#System_Net_Sockets_SocketFlags_DontRoute">DontRoute</a> flag as the socketflags parameter, the data you are sending will not be routed.
</p>
</div>




  <a id="System_Net_Sockets_Socket_SetSocketOption_" data-uid="System.Net.Sockets.Socket.SetSocketOption*"></a>

  <h3 id="System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Boolean_" data-uid="System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
  SetSocketOption(SocketOptionLevel, SocketOptionName, bool)
  
  </h3>

  <div class="markdown level1 summary"><p>Sets the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option to the specified Boolean value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>optionLevel</code> <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a> values.</p>
</dd>
    <dt><code>optionName</code> <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> values.</p>
</dd>
    <dt><code>optionValue</code> <a class="xref" href="System.Boolean.html">bool</a></dt>
    <dd><p>The value of the option, represented as a Boolean.</p>
</dd>
  </dl>












  <a id="System_Net_Sockets_Socket_SetSocketOption_" data-uid="System.Net.Sockets.Socket.SetSocketOption*"></a>

  <h3 id="System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Byte___" data-uid="System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
  SetSocketOption(SocketOptionLevel, SocketOptionName, byte[])
  
  </h3>

  <div class="markdown level1 summary"><p>Sets the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option to the specified value, represented as a byte array.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>optionLevel</code> <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a> values.</p>
</dd>
    <dt><code>optionName</code> <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> values.</p>
</dd>
    <dt><code>optionValue</code> <a class="xref" href="System.Byte.html">byte</a>[]</dt>
    <dd><p>An array of type Byte that represents the value of the option.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Byte____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> options determine the behavior of the current <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. Use this overload to set those <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> options that require a byte array as an option value.
</p>
</div>




  <a id="System_Net_Sockets_Socket_SetSocketOption_" data-uid="System.Net.Sockets.Socket.SetSocketOption*"></a>

  <h3 id="System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Int32_" data-uid="System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
  SetSocketOption(SocketOptionLevel, SocketOptionName, int)
  
  </h3>

  <div class="markdown level1 summary"><p>Sets the specified <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> option to the specified integer value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>optionLevel</code> <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionLevel.html">SocketOptionLevel</a> values.</p>
</dd>
    <dt><code>optionName</code> <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a></dt>
    <dd><p>One of the <a class="xref" href="System.Net.Sockets.SocketOptionName.html">SocketOptionName</a> values.</p>
</dd>
    <dt><code>optionValue</code> <a class="xref" href="System.Int32.html">int</a></dt>
    <dd><p>A value of the option.</p>
</dd>
  </dl>








  <h4 class="section" id="System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Int32__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> options determine the behavior of the current <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a>. For an option with a Boolean data type, specify a nonzero value to enable the option, and a 
zero value to disable the option. For an option with an integer data type, specify the appropriate value. <a class="xref" href="System.Net.Sockets.Socket.html">Socket</a> options are grouped by level of protocol support.
</p>
For <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_Linger">Linger</a> option the <code class="paramref">optionValue</code> it's the number of seconds that the socket will linger before closing the connection.
To disable socket linger call <a class="xref" href="System.Net.Sockets.Socket.html#System_Net_Sockets_Socket_SetSocketOption_System_Net_Sockets_SocketOptionLevel_System_Net_Sockets_SocketOptionName_System_Boolean_">SetSocketOption(SocketOptionLevel, SocketOptionName, bool)</a> with <a class="xref" href="System.Net.Sockets.SocketOptionName.html#System_Net_Sockets_SocketOptionName_DontLinger">DontLinger</a> and setting it to <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/bool">true</a>.
</div>





</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
